\chapter{Debugging RuleWorks Programs}
\label{c:debugging}

You can use the RuleWorks debugging commands to find errors in your
program and to interact with it while it is running. If your program
calls routines written in another language, you must use that
language's debugger to find errors in those routines. That debugger
sees the C code generated by the RuleWorks compiler, not your
RuleWorks source code. \co{DEBUG} qualifier.

\begin{note}
  The RuleWorks debugger, unlike other debuggers, is subordinate---it
  is called from your program. Other debuggers call your program. You
  control the appearance of the RuleWorks interpreter with the Debug
  compilation qualifier, \co{DEBUG} action, and the \co{rul\_debug}
  RTL routine.
\end{note}

\section{Using the RuleWorks Command Interpreter}

The RuleWorks command interpreter lets you interactively control the
execution of an entry block by entering RuleWorks commands.
Table~\ref{t:debcom} lists these commands with their corresponding
operations.

\begin{table}[h]
  \begin{tabularx}{\columnwidth}{XX}
    \toprule
    Commands & Operation \\
    \midrule 
    \verb|@| & Execute contents of a command file. \\\addlinespace
    \co{EBREAK}\newline
    \co{RBREAK}\newline
    \co{WBREAK} & Use breakpoints. \\\addlinespace
    \co{PPCLASS} & Display the inheritance hierarchy
                   of an object class. \\\addlinespace
    \co{PPWM}\newline
    \co{WMHISTORY} & Display objects in working memory. \\\addlinespace
    \co{MAKE}\newline
    \co{MODIFY}\newline
    \co{COPY}\newline
    \co{SPECIALIZE}\newline
    \co{REMOVE}\newline
    \co{REMOVE-EVERY} & Change working memory. \\\addlinespace
    \co{MATCHES} &  Display match information. \\\addlinespace
    \co{CS}\newline
    \co{NEXT} & Display the contents of the conflict set. \\\addlinespace
    \co{TRACE} & Display trace information. \\\addlinespace
    \co{ADDSTATE}\newline
    \co{RESTORESTATE}\newline
    \co{SAVESTATE} & Save and restore visible working memory and
                     active conflict set. \\\addlinespace
    \co{DISABLE}\newline
    \co{ENABLE} & Change the state of program operation. \\\addlinespace
    \co{AFTER} & Set the recognize-act counter for a catcher. \\\addlinespace
    \co{RUN} & Execute recognize-act cycles. \\
    \bottomrule
  \end{tabularx}
  \caption{Debugging Commands}
  \label{t:debcom}
\end{table}

\subsubsection{Entering RuleWorks Commands}

The RuleWorks command interpreter displays the following prompt:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP
\end{Verbatim}
\end{quote}

To enter a RuleWorks command, type the command, with arguments if
appropriate, and then press the Return key. To extend a command over
more than one line, you can either enclose it in parentheses (which
you can optionally use for single-line commands also) or use the
continuation character (\verb|-|).

An example of a single-line command entered, without parentheses, at
the interpreter prompt is shown below:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{cs}
\end{Verbatim}
\end{quote}

If you end a line with the continuation character, the command
interpreter prompts you for the rest of the command each time you
press the \co{Return} key. For example:

\begin{quote}
\begin{verbatim}
RuleWorks>MAKE HD-30 ^IS-EXPANDED YES ^NAME HD-30 ^PART-NUMBER HD-30
_RuleWorks>^PRINT-NAME |30 Megabyte Hard Disk Drive| ^PRICE 599.95
_RuleWorks>^TAKES-SLOT YES
\end{verbatim}
\end{quote}

If you begin a command with a parenthesis, you must make sure you have
the same number of left and right parentheses, because the interpreter
matches each left parenthesis with a corresponding right parenthesis
before it accepts the command.  The \co{MAKE} command above can also
be entered with parentheses but without a continuation character:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{(make hd-30 ^is-expanded yes ^name hd-30 ^part-number hd-30}
\textcolor{rwp-color}{_RuleWorks> }\cmd{^print-name |30 Megabyte Hard Disk Drive| ^price 599.95}
\textcolor{rwp-color}{_RuleWorks> }\cmd{^takes-slot yes)}
\end{Verbatim}
\end{quote}

If you want to include an extra unmatched parenthesis in such a
command, you must enclose it in quote characters, for example,
\verb,||,. Otherwise the interpreter counts it as a parenthesis to be
matched before it allows you to end the command.

Arguments, which can be optional or required, must follow the
command name. If you do not specify a required argument, the
run-time system displays an error message, shows the correct
syntax and an example, and finally redisplays the command
interpreter prompt. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{make}
error: Syntax error:  MAKE command missing required parameters
   Usage:     MAKE  class-name [ \{^attribute value\}... ]
   Example    RuleWorks> make my-part ^number 801 ^color-list[3] yellow
\end{Verbatim}
\end{quote}

\begin{note}
  The command interpreter does not evaluate arguments.  Therefore, you
  cannot use variables as an argument to a RuleWorks
  command. Similarly, you cannot use a call to any function except
  \co{COMPOUND}.
\end{note}

\subsubsection{Exiting the Command Interpreter}

Use the \co{EXIT} command to exit the command interpreter. Depending
on whether your RuleWorks code is set up as a main program or a
callable routine, control returns either to the operating system or to
the calling program.

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{exit}
$
\end{Verbatim}
\end{quote}

\section{Using RuleWorks Command Files}

You can store a list of RuleWorks commands in a file and execute them
later by using the RuleWorks \verb|@| command inside your
\co{ON-ENTRY} statement or at the command interpreter. For example,
you can have an \verb|@| file of \co{MAKE} commands to create objects
when your program starts.

The following command opens the file \co{ORDER.WM} and causes the
command interpreter to execute the commands stored in that file:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{@ order.wm}
\end{Verbatim}
\end{quote}

If the file you specify with the \verb|@| command contains information
other than RuleWorks commands, the run-time system displays an error
message. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{@ order.dat}
error: Syntax error: unknown command 'home-Kiwi'
\end{Verbatim}
\end{quote}

\section{Using Breakpoints}

A breakpoint causes your program to pause under certain conditions: a
specified rule is about to be executed or an object that matches a
specified pattern has just been created, changed, or deleted. You can
set, delete, and list breakpoints by using the \co{EBREAK} command for
entry blocks; the \co{RBREAK} command for rules and rule groups; and
the \co{WBREAK} command for WMOs.

When the run-time system encounters a breakpoint, the system finishes
executing the current recognize-act cycle, displays an informational
message, and then invokes the command interpreter, to allow you to
enter debugging commands. The format of the message depends on your
operating system. For example, on VMS systems:

\begin{quote}
\begin{verbatim}
%RUL-I-EBREAK, EBREAK encountered; pausing after ON-ENTRY in MAIN
\end{verbatim}
\end{quote}

If a breakpoint is set for an entry block, the run-time system pauses
for the breakpoint after executing the \co{ON-ENTRY} and \co{ON-EXIT}
clauses (if any) of the entry block. If a breakpoint is set for a
rule, the run-time system pauses for the breakpoint just before
executing that rule. Setting a breakpoint on a rule group is
equivalent to setting breakpoints on every rule in the group. If a
breakpoint is set for an object pattern, the run-time system pauses
for the breakpoint after executing the rule that created, changed, or
deleted the object.

\subsubsection{Setting Breakpoints}

To set a breakpoint, specify the \co{EBREAK}, \co{RBREAK}, or
\co{WBREAK} command with the keyword \co{ON} and the name of the entry
block or rule, or a pattern matched by the WMO.

You can give more than one name with a break command. For example, the
following command sets breakpoints on two rules:
\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{rbreak on verify-conf:need-memory choose-slots:place-memory}
\end{Verbatim}
\end{quote}

The \co{WBREAK} command accepts at most one object pattern. This
pattern is similar to a CE but more limited: it must include an
object class name and can also include attributes with
predicates and values. It cannot include variables, function
calls or other expressions.

For example, suppose a breakpoint is already set for objects of class
\co{FLOPPY}. The following two commands set a new breakpoint for objects
with class name \co{DISK} and \verb|^PRICE| identical to 299.95, and delete
the old one on class \co{FLOPPY}:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wbreak on disk ^price 299.95}
\end{Verbatim}
\end{quote}

When you specify an object class that has inheriting subclasses,
objects of those subclasses are also affected by the \co{WBREAK}
commands. Thus, the command above affects objects of classes
\co{DISK}, \co{FLOPPY}, \co{FD-5}, \co{FD-35}, \co{HARD-DISK},
\co{HD-30}, and \co{HD-200}. See Chapter~\ref{c:workingmem} for an
illustration of the class inheritance hierarchy of the sample program
\co{KIWI}.

\subsubsection{Listing Breakpoints}

To see what breakpoints are set, use the \co{EBREAK}, \co{RBREAK}, or
\co{WBREAK} command without any keyword or arguments. The following
example shows that breakpoints are set for two rules:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{rbreak}
   RBREAKs set on:
   1  VERIFY-CONFIGURATION:NEED-MEMORY
   2  CHOOSE-SLOTS:PLACE-MEMORY
\end{Verbatim}
\end{quote}

This example shows that breakpoints are set for certain objects of
class \co{DISK}:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wbreak}
   WBREAKs set on:
   1  (DISK ^PRICE <= 299.95)
\end{Verbatim}
\end{quote}

\subsubsection{Deleting Breakpoints}

To delete a breakpoint, specify the \co{EBREAK}, \co{RBREAK}, or
\co{WBREAK} command with the keyword \co{OFF}, and one of the following:

\begin{itemize}
\item the name of the entry block or rule, or a pattern matched by a
  WMO, that has a breakpoint set,
\item a number displayed by a break command when given no arguments
  (as shown above),
\item an asterisk (\verb|*|).
\end{itemize}

Use an asterisk to delete all breakpoints. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{rbreak off *}
\RWP\cmd{rbreak}
   No RBREAKs set.
\end{Verbatim}
\end{quote}

\section{Displaying the Inheritance Hierarchy}

Use the \co{PPCLASS} command with the name of an object class to
display the inheritance hierarchy of that class. This command lists
the ancestors of the class you specify, starting at the top-level
user-defined class. All attributes declared for that class, including
those it inherits, are shown after the class name. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{ppclass box}
   PART
   BOX
      ^$ID instance-id of BOX
      ^$INSTANCE-OF symbol (default BOX)
      ^PARTNUMBER
      ^NAME
      ^PRICE
      ^IS-EXPANDED (default NO)
      ^CARD-IN-SLOT compound
      ^CARD-IN-SLOT-OBJ-ID compound
\end{Verbatim}
\end{quote}

An attribute's default and fill values, if any, are shown inside
parentheses after the attribute's name. Compound attributes are also
identified as such.

To display which object classes are visible to the active entry block,
use the \co{PPCLASS} command with no argument. This shows the name of the
entry block (and declaration blocks, if any) and the top-level
user-defined classes only. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{ppclass}
   Entry block CONFIG
       LOCAL
     Declaration block KIWI_DECLS
       CONTROL-CONTEXT
       ERROR
       INPUT-THING
       PART
\end{Verbatim}
\end{quote}

\section{Displaying Working-Memory Objects}

During a debugging session, you can examine the contents of working
memory to make sure it contains correct information.  Missing or
erroneous objects can cause a rule to be executed at the wrong
time. The \co{WM}, \co{PPWM}, and \co{WMHISTORY} commands display the
contents of working memory:

\begin{table}
  \begin{tabularx}{\columnwidth}{lX}
    \toprule
    Command & Description \\
    \midrule
    \co{WM} &  Displays all objects or objects with specified 
              \co{INSTANCE-ID}s. \\
    \co{PPWM} & Displays all objects or objects that match a 
                specified pattern. \\
    \co{WMHISTORY} & Displays the revision history of the object with
                     a specified \co{INSTANCE-ID}, or of a specified  
                     attribute of that object. \\
    \bottomrule
  \end{tabularx}
  \caption{Working Memory Commands}
  \label{t:9-2}
\end{table}

The \co{WM} and \co{PPWM} commands provide the following information
about each object:

\begin{itemize}
\item Its \co{INSTANCE-ID}.
\item Its time-tag.
\item The name of the rule that set the time-tag (that is, the rule
  that last modified the object).
\item Its object class name, its attributes, and the attributes'
  values.
\end{itemize}
  
The run-time system displays this information in the following
format:

\begin{quote}
  \co\#\it{INSTANCE-ID} \it{time-tag} \co[\it{rule-name}\co]
  \co(\it{class-name} \ct\it{attr-1} \it{value-1}
  \ct\it{attr-2} \it{value-2} \ldots\co)
\end{quote}

The \co{WMHISTORY} command provides the following information about an
object:

\begin{itemize}
\item Its \co{INSTANCE-ID}.
\item Its time-tag.
\item The name of the rule that last modified it.
\item Its object class name.
\item The name of the rule that set the object class name (that is,
  the rule that originally created the object).
\item Its attributes, the attributes' current values, and the naqmes
  of the rules that set the attributes' current values.
\end{itemize}

The run-time system displays this information in the following format:

\begin{quote}
  \co\#\it{INSTANCE-ID} \it{time-tag} \co[\it{rule-name-n}\co]
  \co(\it{class-name} \co[\it{rule-name}\co] \{\it{attr-1}
  \it{value-1} \co[\it{rule-name-1}\co]\}\co)
\end{quote}

When you create or change an object with an action contained in an
\co{ON-} statement, the name of that statement appears inside the
brackets rather than a rule name. When you use a command, the atom
\co{RUL} appears.

The run-time system does not print an empty attribute unless you have
specified a \co{DEFAULT} value for it. Empty is defined as a \co{NIL}
value for scalar attributes, \co{(COMPOUND)} for compound attributes.
Attributes that have a \co{DEFAULT} declaration are always printed.

\subsubsection{Displaying the Contents of Working Memory}

To display the entire contents of working memory, use either the
\co{WM} or \co{PPWM} command without an argument. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wm}
   #1 1 [ON-ENTRY] (CONTEXT ^NAME TASKS-TO-DO)
   #2 2 [TASKS-TO-DO:TASKS-TO-DO] (CONTEXT ^NAME OUTPUT-NEW-ORDER)
   #3 3 [TASKS-TO-DO:TASKS-TO-DO] (CONTEXT ^NAME MODIFY-SOFTWARE-MEDIA)
   #4 4 [TASKS-TO-DO:TASKS-TO-DO] (CONTEXT ^NAME CHOOSE-SLOTS)
\end{Verbatim}
\end{quote}

Object \verb|#1| was made in the \co{ON-ENTRY} statement, so that name
appears inside the brackets instead of the name of a rule.

\subsubsection{Displaying Specific Working-Memory Objects}

To display particular objects, specify their \co{INSTANCE-ID}s with
the \co{WM} command. The following example displays the objects that
have \co{INSTANCE-ID}s \verb|#23| and \verb|#24|:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wm #23 #24}
   #23 27 [VERIFY-CONFIGURATION:MOUSE-PORT]
          (ERROR ^SEVERITY WARNING ^MESSAGE |Missing mouse port|)
   #24 28 [VERIFY-CONFIGURATION:MOUSE-PORT]
          (KEYBOARD ^IS-EXPANDED NO ^IS-PLACED NO)
\end{Verbatim}
\end{quote}

You can find out which \co{INSTANCE-ID}s are assigned to which
objects by setting the run-time system's \co{TRACE} level to \co{WM}. For
further information on trace levels, See the Displaying Trace
Information section of this chapter.

\subsubsection{Displaying the History of Specific Working-Memory
  Objects}

To display the names of the rules that have created or modified a
particular object, specify the \co{INSTANCE-ID} of that object with
the \co{WMHISTORY} command. By default, the \co{WMHISTORY} command is
disabled. You must enable it with the \co{ENABLE} command before
running the rules that affect the objects you want to display.  The
following example shows the history of the object whose
\co{INSTANCE-ID} is \verb|#36|:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{enable wmhistory}
\RWP\cmd{run 45}
\RWP\cmd{wmhistory 36}
   #36 41 [EXPAND-PART-SKELETONS:FD-35] (FD-35
   [VERIFY-CONFIGURATION:NEED-DISK] ^ TAKES-SLOT YES
   [EXPAND-PART-SKELETONS:FD-35] ^NAME FD-35
   [EXPAND-PART-SKELETONS: FD-35] ^PART-NUMBER FD-35
   [EXPAND-PART-SKELETONS:FD-35] ^PRINTNAME 3.5" Floppy Disk
   Drive [EXPAND-PART-SKELETONS:FD-35] ^PRICE 99.95
   [EXPAND-PART-SKELETONS:FD- 35] ^IS-EXPANDED YES
   [EXPAND-PART-SKELETONS:FD-35])
\end{Verbatim}
\end{quote}

In this example, the \co{WMHISTORY} command shows that the rule
\co{EXPAND-PART-SKELETONS:FD-35} most recently changed this object,
because that is the rule shown after the time-tag. Another rule,
\co{VERIFY-CONFIGURATION:NEED-DISK}, originally created the object,
because that is the rule shown after the class name. The rule
\co{EXPAND-PART-SKELETONS:FD-35} set the values of all the attributes.

If you are interested in which rule set a particular attribute value,
you can specify the attribute name with the \co{WMHISTORY} command:
\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wmhistory #36 ^price}
     #36 41 [EXPAND-PART-SKELETONS:FD-35]
     (FD-35 [VERIFY-CONFIGURATION:NEED-DISK]
     ^PRICE 99.95 [EXPAND-PART-SKELETONS:FD-35])
\end{Verbatim}
\end{quote}

When you use a command rather than an action inside a rule to create
or modify an object, the atom \co{RUL} rather than the name of a rule
appears inside the brackets after the time-tag, class name, or
attribute value. When you use an action inside an \co{ON-} statement,
the name of that statement appears inside the brackets.

\subsubsection{Displaying the Working-Memory Objects of an Object
  Class}

To display the objects of a particular object class, use the \co{PPWM}
command with the name of that class. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{ppwm error}
     #23 27 [VERIFY-CONFIGURATION:MOUSE-PORT]
            (ERROR ^SEVERITY WARNING ^MESSAGE |Missing mouse port|)
     #25 29 [VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS]
            (ERROR ^SEVERITY WARNING ^MESSAGE |Missing operating system|)
     #27 31 [VERIFY-CONFIGURATION:KIWOS-MEMORY]
            (ERROR ^SEVERITY WARNING ^MESSAGE |Missing memory|)
\end{Verbatim}
\end{quote}

If you specify the name of an object class that has inheriting
subclasses, objects of those subclasses are also displayed. For
example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{ppwm software-option}
     #27 69 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST]
            (KIWICALC ^MEDIA-TYPE FD-35 ^NAME KIWICALC
            ^PART-NUMBER S-CA-9200
            ^PRINTNAME KiwiCalc Spreadsheet Software ^PRICE 29.95
            ^IS-EXPANDED YES)
     #29 70 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST]
            (KIWINDOWS ^MEDIA-TYPE FD-35 ^NAME KIWINDOWS
            ^PART-NUMBER S-WI-9200
            ^PRINTNAME KiWindows Windows Software ^PRICE 59.95
            ^IS-EXPANDED YES)

     #39 71 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST]
            (KIWOS ^MEDIA-TYPE FD-35 ^NAME KIWOS 
            ^PART-NUMBER S-OS-9200
            ^PRINTNAME KIWOS Operating System ^PRICE 9.95 
            ^IS-EXPANDED YES)
\end{Verbatim}
\end{quote}

(See Chapter~\ref{c:workingmem} for an illustration of the class
inheritance hierarchy of the sample program \co{KIWI.RUL}.)

\subsubsection{Displaying Working-Memory Objects that Match a Pattern}

To display the objects that match a specific object pattern, use the
\co{PPWM} command with an object class name followed by the pattern
you want to match. This pattern is similar to an attribute-value test
but variables and function calls are not allowed, except
\co{COMPOUND}.

The following example displays all parts that match the object pattern
\verb|^PRICE < 50.00|. The \verb|^PRICE| attribute is first declared
in the \co{PART} class. Therefore, to display all objects that have
the \verb|^PRICE| attribute, the object class name \co{PART} is
specified in the \co{PPWM} command. The objects that actually match
the pattern are instances of classes \co{KIWICALC} and \co{KIWOS}:
\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{ppwm part ^price < 50.00}
     #27 69 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST]
            (KIWICALC ^MEDIA-TYPE FD-35 ^NAME KIWICALC 
            ^PART-NUMBER S-CA-9200
            ^PRINTNAME KiwiCalc Spreadsheet Software ^PRICE 29.95
            ^IS-EXPANDED YES)

     #39 71 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST]
            (KIWOS ^MEDIA-TYPE FD-35 ^NAME KIWOS 
            ^PART-NUMBER S-OS-9200
            ^PRINTNAME KIWOS Operating System ^PRICE 9.95
            ^IS-EXPANDED YES)
\end{Verbatim}
\end{quote}

\section{Modifying Working Memory}

If working memory contains incorrect information, the rules in a
program might not execute as you anticipate. You can modify
working memory by:

\begin{itemize}
  \item Creating objects
  \item Copying objects
  \item Deleting objects
  \item Changing the values in existing objects
\end{itemize}

\subsubsection{Creating Working-Memory Objects}

You can create a new object by using the \co{MAKE} command with an
object class name. You can optionally specify attributes with constant
values or the \co{COMPOUND} function with constant arguments. The
following command creates an object with the class name
\co{INPUT-THING} and a value for its \verb|^ITEM| attribute.

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{make input-thing ^item keyboard}
\end{Verbatim}
\end{quote}

The object could be displayed as follows:

\begin{quote}
\begin{verbatim}
#18 20 [RUL] (INPUT-THING ^ITEM KEYBOARD)
\end{verbatim}
\end{quote}  

Because the object was created by a command, the atom \co{RUL} is used
instead of the name of a rule that set the time-tag.

\subsubsection{Copying Working-Memory Objects}

You can make a new copy of an existing object by using the \co{COPY}
command with an \co{INSTANCE-ID}. You can optionally specify
attributes with values. The following command creates another object
of class \co{FD-35} with a different attribute value:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{copy #36 ^price 119.95}
\RWP\cmd{ppwm fd-35 ^price 119.95}
    #45 63 [RUL] (FD-35 [RUL] ^TAKES-SLOT YES ^NAME FD-35
    ^PART-NUMBER FD-35 ^ PRINTNAME 3.5" Floppy Disk Drive
    ^PRICE 199.95 ^IS-EXPANDED YES)
\end{Verbatim}
\end{quote}

\co{RUL} is placed in the fields that store the names of the rules
that created the object and that last modified it. Note that both the
\co{INSTANCE-ID} and the time-tag of the new object are different from
the older object.

\subsubsection{Changing the Class of Objects}

You can change the class of an object from a parent class to a
subclass with the \co{SPECIALIZE} command. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{ppwm #48}
     #48 54 [RUL] (FLOPPY ^IS-EXPANDED NO ^IS-PLACED NO)
\RWP\cmd{specialize #48 fd-5}
\RWP\cmd{ppwm #48}
     #48 55 [RUL] (FD-5 ^IS-EXPANDED NO ^IS-PLACED NO)
\end{Verbatim}
\end{quote}

\begin{note}
  The converted object's \co{INSTANCE-ID} does not change as a result
  of this action, but the time-tag does change. You can also change
  attribute values with this command.
\end{note}

\subsubsection{Deleting Objects from Working Memory}

The \co{REMOVE} command deletes objects from working memory. To delete
specific objects, specify their \co{INSTANCE-ID}s. The following
example deletes the objects whose identifiers are \verb|#20| and
\verb|#63|:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{remove #20 #63}
\end{Verbatim}
\end{quote}

To delete all visible objects, specify the command with an asterisk
(\verb|*|). For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{remove *}
\end{Verbatim}
\end{quote}

To delete all instances of an object class and its subclasses, use the
\co{REMOVE-EVERY} command. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{remove-every input-thing}
\end{Verbatim}
\end{quote}

\subsubsection{Changing the Values in Working-Memory Objects}

To change one or more values in an object, use the \co{MODIFY} command with
the \co{INSTANCE-ID} of the object whose atoms you want to change, and
specify the attributes and their new values.  Suppose, for example,
working memory contains the following objects:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{ppwm input-thing}
    #16 17 [READ-LINE-ITEM:READ-AN-ITEM] (INPUT-THING ^ITEM HOME-KIWI)
    #17 19 [READ-LINE-ITEM:READ-AN-ITEM] (INPUT-THING ^ITEM MOUSE)
    #18 21 [READ-LINE-ITEM:READ-AN-ITEM] (INPUT-THING ^ITEM KIWINDOWS)
\end{Verbatim}
\end{quote}

The following command changes the atom for the attribute \verb|^ITEM|
of the object whose \co{INSTANCE-ID} is \verb|#16|:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{modify #16 ^item business-kiwi}
\end{Verbatim}
\end{quote}

The run-time system then changes that attribute and gives the object a
new time-tag:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wm #16}
   #16 22 [RUL] (INPUT-THING ^ITEM BUSINESS-KIWI)
\end{Verbatim}
\end{quote}

Note that the \co{INSTANCE-ID} remains the same.

\section{Displaying Match Information}

By examining match information, you can detect whether condition
elements are being matched correctly by WMOs. You can display match
information for specific rules by using the \co{MATCHES} command.

Match information includes the \co{INSTANCE-ID}s and time-tags of
objects that match CEs in the rules you specify. First, the command
displays the name of the rule. Then the command lists the time-tags
for the objects that match the first CE, the second CE, the first and
second CEs, and so on. For example, consider the following rule:

\begin{quote}
\begin{verbatim}
(rule choose-slots:place-memory
    (active-context ^name choose-slots)
    (box ^$ID <the-box> ^card-in-slot { [=] <len> [<] 6 })
    (memory ^$ID <the-mem> ^is-placed nil ^takes-slot yes)
  -->
    (modify <the-box>
        ^card-in-slot [(<len> + 1)] memory
        ^card-in-slot-obj-id [(<len> + 1)] <the-mem>)
    (modify <the-mem> ^is-placed yes ^in-slot (<len> + 1)))
\end{verbatim}
\end{quote}

The following objects:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wm #27 #37 #38 #46}
  #27 59 [EXPAND-PART-SKELETONS:BOX] (BOX ^NAME BOX ^PART-NUMBER
  KI-9200 ^PRINTNAME Kiwi-9200 CPU Base Unit ^PRICE 999.95
  ^IS-EXPANDED YES)
  #37 54 [EXPAND-PART-SKELETONS:MEMORY] (MEMORY ^TAKES-SLOT YES
  ^NAME MEMORY-CARD ^PART-NUMBER MS-9200 ^PRINTNAME Kiwi-9200
  Memory card ^PRICE 129.95 ^IS-EXPANDED YES)
  #38 53 [EXPAND-PART-SKELETONS:MEMORY] (MEMORY ^TAKES-SLOT YES
  ^NAME MEMORY-CARD ^PART-NUMBER MS-9200 ^PRINTNAME Kiwi-9200
  Memory card ^PRICE 129.95 ^IS-EXPANDED YES
  #46 60 [MAKE-CONTEXT-ACTIVE] (ACTIVE-CONTEXT ^NAME
  CHOOSE-SLOTS))
\end{Verbatim}
\end{quote}

And the following \co{MATCHES} command:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{matches choose-slots:place-memory}
     >>> CHOOSE-SLOTS:PLACE-MEMORY <<<
     *** matches for 1 ***
       #46
     *** matches for 2 ***
       #27
     *** matches for 1 2 ***
       #46 #27
     *** matches for 3 ***
       #38
       #37
     *** complete instantiations ***
       #46 #27 #37
       #46 #27 #38
\end{Verbatim}
\end{quote}

The first five lines of output show that the object whose
\co{INSTANCE-ID} is \verb|#46| matches the first CE in the rule and
the object whose \co{INSTANCE-ID} is \verb|#27| matches the second
CE. These are called intraelement matches because each CE is
considered individually. The next two lines show that the combination
of these two objects matches the combination of the first and second
CEs. This is called an interelement match.

The \co{MATCHES} command then displays the intraelement matches for
the third CE, the objects whose \co{INSTANCE-ID}s are \verb|#37| and
\verb|#38|.  Note that each match is displayed on a separate line.

Finally, the command displays the instantiations of the rule.  Because
two objects match one of the CEs, there are two instantiations.

Instantiations removed from the active conflict set by refraction are
not included in the \co{MATCHES} output.

\subsection{Match Information for Negated CEs}

Negated CEs are represented in the match information by headers just
like the headers for positive CEs. For example, the rule
\co{VERIFY-CONFIGURATION:MOUSE-PORT} has two positive CEs and one
negated CE:

\begin{quote}
\begin{verbatim}
(rule verify-configuration:mouse-port
    (active-context ^name verify-configuration)
    (mouse)
    -(keyboard)
  -->
    (make error ^severity warning ^message |Missing mouse port|)
    (write (crlf) |Caution: You want a mouse, but you don't have a|
        (crlf) | mouse controller port, which is part of the keyboard|
        (crlf) | Fixup: adding a keyboard to your order.|
        (crlf))
    (make keyboard))
\end{verbatim}
\end{quote}

The match information for this rule is shown below:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{matches verify-configuration:mouse-port}
     >>> VERIFY-CONFIGURATION:MOUSE-PORT <<<
     *** matches for 1 ***
       #43
     *** matches for 2 ***
       #31
     *** matches for 1 2 ***
       #43 #31
     *** matches for 3 ***
     *** complete instantiations ***
       #43 #31
\end{Verbatim}
\end{quote}

There is a complete instantiation of this rule in the conflict set
(because) there is no match for the negated third CE.

\subsection{Match Information for Interelement Variables}

Interelement variables are bound in one CE and then used again in
another CE. In match information, interelement variables result in
fewer than expected matches for combinations of CEs, compared to the
number of matches for individual CEs.

For example, suppose working memory contains the following objects:

\begin{quote}
\begin{verbatim}
  #26 42 (BOX)
  #28 65 (BOX ^CARD-IN-SLOT-OBJ-ID (COMPOUND #31)
  #31 64 (MEMORY ^IN-SLOT 1 ^IS-PLACED YES)
  #35 66 (MEMORY ^IN-SLOT 1 ^IS-PLACED YES)
  #39 69 (MEMORY ^IN-SLOT 2 ^IS-PLACED YES)
\end{verbatim}
\end{quote}

And the program contains this rule

\begin{quote}
\begin{verbatim}
(rule display-memory-cards
    (memory ^$ID <mem> ^is-placed yes)
    (box ^$ID <box> ^card-in-slot-obj-id [+] <mem>)
  -->
    (write (crlf) box <box> contains memory card <mem>))
\end{verbatim}
\end{quote}

The following command displays the matches for this rule:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{matches display-memory-cards}
     >>> DISPLAY-MEMORY-CARDS <<<
     *** matches for 1 ***
       #31
       #35
       #39
     *** matches for 2 ***
       #26
       #28
     *** complete instantiations ***
       #31 #28
\end{Verbatim}
\end{quote}

There are three intraelement matches for the first CE and two for the
second CE, so you might expect six matches for the entire
LHS. However, the interelement variable \verb|<MEM>| limits the
interelement matches to the combination of \co{MEMORY} \verb|#31| with
\co{BOX} \verb|#28|.

\section{Displaying Conflict Set Information}

The instantiations in the conflict set indicate which rules can be
executed. You can display the entire contents of the conflict set or
the instantiation of the next rule to be executed. The run-time system
displays instantiations in the following format:

\begin{quote}
  \it{rule-name} \verb|#|\it{INSTANCE-ID-1} \it{time-tag-1}
  \verb|#|\it{INSTANCE-ID-2} \it{time-tag-2} \ldots
\end{quote}

\subsection{Displaying the Contents of the Conflict Set}

The \co{CS} command displays the entire contents of the conflict set.
For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{cs}
  \ldots
  VERIFY-CONFIGURATION:KIWINDOWS-NEEDS-2-MEMORY-CARDS-FOUND-NONE
      #32 36 #29 33
  VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS #32 36 #29 33
  VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS #32 36 #27 31
  VERIFY-CONFIGURATION:NEED-DISK #32 36
  VERIFY-CONFIGURATION:NEED-OUTPUT #32 36
  VERIFY-CONFIGURATION:NEED-MEMORY #32 36
\end{Verbatim}
\end{quote}

To display the instantiation of the next rule the run-time
system will execute, use the \co{NEXT} command. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{next}
  VERIFY-CONFIGURATION:KIWINDOWS-NEEDS-2-MEMORY-CARDS-FOUND-NONE
  #32 36 #29 33
\end{Verbatim}
\end{quote}

This shows that the next rule the run-time system will execute is
\co{VERIFY-CONFIGURATION:KIWINDOWS-NEEDS-2-MEMORY-CARDS-FOUND-NONE}.
The rule will be executed with its CEs matched by the objects whose
\co{INSTANCE-ID}s are \verb|#32| and \verb|#29|.

\section{Displaying Trace Information}

The RuleWorks run-time system displays trace information while
executing a program. Trace information can be enabled for entry blocks
(\co{EB}), rule groups (\co{RG}), rules, working memory (\co{WM}), and
the conflict set (\co{CS}).

\subsection{Setting the Trace Level}

To set the trace level, specify the \co{TRACE} command with the
keyword \co{ON} or \co{OFF} and the type of information you want
traced or not. The following table shows the valid keywords for the
\co{TRACE} command. The default setting is \co{OFF *}.

\begin{center}
\begin{tabular}{ll}
  \toprule
  Name & Trace Information Affected \\
  \midrule
  \co{ENTRY-BLOCK} or \co{EB} & Entry blocks entered and exited \\
  \co{RULE-GROUP} or \co{RG} & Rule group containing rule that just fired \\
  \co{RULE} & Rule firing counts and name of rule that just fired \\
  \co{WM} & Changes to working memory \\
  \co{CS} & Changes to the conflict set \\
  \co{*} &  All trace information \\
  \bottomrule
\end{tabular}
\end{center}

For example, if you want the system to display as much trace
information as possible, you can list all the keywords or use the
asterisk (\co{*}):

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace on eb rg rule wm cs}
\end{Verbatim}
or
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace *}
\end{Verbatim}
\end{quote}

\subsection{Displaying the Current Trace Level}

To display the current trace level, use the \co{TRACE} command without
an argument. For example:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace}
   TRACE set on: ENTRY-BLOCK RULE-GROUP RULE WM C
\end{Verbatim}
\end{quote}

\subsection{Tracing Entry Blocks}

The \co{TRACE ON EB} command causes trace messages to be generated
upon entering an entry block (before any \co{ON-ENTRY} actions are
executed) and upon exiting (after any \co{ON-EMPTY} or \co{ON-EXIT}
actions are executed).

The trace output for entry blocks includes the name of the entry
block. Trace output for entry blocks starts in column one. All
other trace messages are indented. The following example shows
sample trace output on entry blocks in italic type.

\begin{note}
  The output of the following four examples are taken from a telephone
  directory program that uses the similarity predicate to find names
  that sound alike.
\end{note}

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace on eb}
\RWP\cmd{run}
Name to look up: \cmd{stefan pelican}
-->Entry-Block: LOOKUP_PHONE_NUMBER
Could not find any likely matches for stefan pelican.
<--Entry-Block: LOOKUP_PHONE_NUMBER

Name to look up: \cmd{stefan polocave}
-->Entry-Block: LOOKUP_PHONE_NUMBER
Found one potential match for stefan polocave.
The number for Steve Polikoff is 555-5391.
<--Entry-Block: LOOKUP_PHONE_NUMBER
\end{Verbatim}
\end{quote}

\subsection{Tracing Rule Groups}

The \co{TRACE RG} command causes trace messages to be generated
whenever the rule group that contains the firing rule is different
from the rule group that contains the previously fired rule. The trace
output for rule groups contains the name of the rule block or entry
block that contains the rule group, as well as the name of the rule
group itself. The system displays this information in the following
format:

\begin{quote}
  \co{RULE-GROUP:} \it{rule-group-name} \verb|[in| \it{rule-block-name}\verb|] in|
  \it{entry-block-name}
\end{quote}

\subsection{Tracing Rules}

The \co{TRACE RULE} command causes a trace message to be generated
each time the system executes a rule. Trace output for rule
firings contains the following information:

\begin{itemize}
\item The global rule-firing count (total number of recognize-act
  cycles in the program).
\item The local rule-firing count (number of recognize-act cycles in
  this invocation of the active entry block).
\item The name of the rule executed.
\item The \co{INSTANCE-ID}s and time-tags of the objects that matched the
  rule's CEs, in order.
\end{itemize}
  
The run-time system displays this information in the following format:

\begin{quote}
  \it{global} \verb|(|\it{local}\verb|):| \it{rule-name}
  \verb|#|\it{instance-id-1} \it{time-tag-1}
  \verb|#|\it{instance-id-2} \it{time-tag-2} \ldots
\end{quote}

In the following example trace information for rules is shown in
italic print.

\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace on eb rule}
\RWP\cmd{run}
Name to look up: \cmd{konny oiljars}
-->Entry-Block: LOOKUP_PHONE_NUMBER
   \it{1 (1): INIT-PHONE-BOOK #41 41}
   \it{2 (2): LAST-RESORT:PRINT-ALL-SIMILAR #42 42 #41 41 #30 30}
Could not find a probable match for konny oiljars
but found potential matches
---->Entry-Block: PRINT_SIMILAR_NAMES
   \it{3 (1): PRINT-ALL-WITH-SIMILAR-LAST-NAME #65 65 #30 30}
\cmd{Connie Olegarz}
<---Entry-Block: PRINT_SIMILAR_NAMES
<---Entry-Block: LOOKUP_PHONE_NUMBER
\end{Verbatim}

\subsection{Tracing Working Memory}

When the trace level includes \co{WM}, the run-time system displays
changes to working memory (that is, objects created, changed, or
deleted). The system displays the following information for each
object:

\begin{itemize}
\item Its \co{INSTANCE-ID}.
\item Its time-tag.
\item The name of the rule that added, changed, or deleted it.
\item Its attributes and their values.
\end{itemize}

The system displays working memory trace information in the
following format:

\begin{quote}
  \verb|#|\it{INSTANCE-ID} \it{time-tag}
  \verb|[|\it{rule-name}\verb|]| \verb|(|\it{class-name} \it{attr-1}
  \it{value-1} \it{attr-2} \it{value-2} \ldots\verb|)|
\end{quote}

Each line of a working memory trace output is preceded by a symbol
that indicates the nature of the change as shown in the following
table.

\begin{center}
  \begin{tabular}{ll}
    \toprule
    Symbol & Meaning \\
    \midrule
    \verb|=>WM:| & Object added to working memory \\
    \verb|<=WM:| & Object deleted from working memory \\
    \bottomrule
  \end{tabular}
\end{center}

When an object is modified or specialized, the system displays two
lines of output: the first shows the old version being deleted, the
second shows the new version being added. The \co{INSTANCE-ID}, of
course, does not change.

In the case of a \co{SPECIALIZE} action, the attribute changed is
\verb|^$INSTANCE-OF|.

In the following example, trace output for working memory
changes is shown in \it{italic} print.

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace on eb rule wm}
\RWP\cmd{run}
    Name to look up: \cmd{Jenny Baker}
    -->Entry-Block: LOOKUP_PHONE_NUMBER
    =>WM: #65 65 [ON-ENTRY] (REQUEST ^FIRST-NAME |Jenny| ^LAST-NAME |Baker|)
    3 (1): LAST-RESORT:PRINT-ALL-SIMILAR #42 42 #65 65 #3 3

    Could not find a probable match for Jenny Baker
    but found potential matches --
    -->Entry-Block: PRINT_SIMILAR_NAMES
    =>WM: #66 66 [ON-ENTRY] (REQUEST ^LAST-NAME |Baker|)
    4 (1): PRINT-ALL-WITH-SIMILAR-LAST-NAME #66 66 #3 3

    Ginny Baccer
    <--Entry-Block: PRINT_SIMILAR_NAMES
    <=WM: #66 66 [ON-ENTRY] (REQUEST ^LAST-NAME |Baker|)
    <--Entry-Block: LOOKUP_PHONE_NUMBER
    <=WM: #65 65 [ON-ENTRY] (REQUEST ^FIRST-NAME |Jenny| ^LAST-NAME |Baker|)
\end{Verbatim}
\end{quote}

When all visible objects are deleted (for example, in a
\co{RESTORESTATE} or \co{REMOVE *} action), the system displays:

\begin{quote}
\begin{verbatim}
 <=WM: ** All Objects Removed **
\end{verbatim}
\end{quote}

\subsection{Tracing the Conflict Set}

When the trace level includes \co{CS}, the run-time system displays
the instantiations added to and deleted from the conflict set.  The
system displays the following information for each instantiation:

\begin{itemize}
\item The name of the rule for which it was added or deleted.
\item The \co{INSTANCE-ID}s and time-tags of the objects that match
  the rule's LHS.
\end{itemize}

The system displays conflict set trace information in the following
format:

\begin{quote}
  \it{rule-name} \verb|#|\it{INSTANCE-ID-1} \it{time-tag}
  \verb|#|\it{INSTANCE-ID-2} \it{time-tag-2}
\end{quote}

Each line of conflict set trace output is preceded by a symbol that
indicates whether the instantiation was added to or deleted from the
conflict set:

\begin{center}
\begin{tabular}{ll}
  \toprule
  Symbol & Meaning \\
  \midrule
  \verb|=>CS:| & Instantiation added to conflict set \\
  \verb|<=CS:| & Instantiation deleted from conflict set \\
  \bottomrule
\end{tabular}
\end{center}

In the following example, trace output about the conflict set is
shown in \it{italic} print.

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace on eb rule wm cs}
\RWP\cmd{run}
    Name to look up: \cmd{Anne Beauchant}
    -->Entry-Block: LOOKUP_PHONE_NUMBER
    =>WM: #69 69 [ON-ENTRY] (REQUEST ^FIRST-NAME |Anne| 
        ^LAST-NAME |Beauchant|
    \it{=>CS: LAST-SIMILAR-AND-FIRST-SIMILAR #44 44 #69 69 #2 2}
    \it{=>CS: LAST-RESORT:PRINT-ALL-SIMILAR #42 42 #69 69 #2 2}
    \it{=>CS: LAST-RESORT:NO-MATCHES-AT-ALL #42 42 #69 69}
    7 (1): LAST-SIMILAR-AND-FIRST-SIMILAR #44 44 #69 69 #2 2
    Found a possible match for Anne Beauchant. 
    The number for Ann Bachant is 555-5619.
    <--Entry-Block: LOOKUP_PHONE_NUMBER
    <=WM: #69 69 [ON-ENTRY] (REQUEST ^FIRST-NAME |Anne|
        ^LAST-NAME |Beauchant|)
\end{Verbatim}
\end{quote}

When all conflict set elements are deleted, the system displays:

\begin{quote}
\begin{verbatim}
<=CS: ** All CS Entries Removed **
\end{verbatim}
\end{quote}

\section{Saving and Restoring Program State}

If you are debugging a RuleWorks program and you need to stop
execution to do something else, you might want to save the state
of working memory and the conflict set as it exists at that
time. Or, you might want to save a certain state so that you can
rerun from that point many times. By using RuleWorks commands
you can save the state to a file and then restore it later.

\subsection{\co{SAVESTATE} Command}

You can copy the state of visible working memory and the active
conflict set to a file by using the \co{SAVESTATE} command. The
following command copies the state of working memory and the
conflict set to the file \co{MY\_SAVE.DAT}:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{savestate my_save.dat}
\end{Verbatim}
\end{quote}  

\begin{note}
  The state of user-defined external routines and open files is not
  saved by the \co{SAVESTATE} command and thus cannot be restored with
  the \co{ADDSTATE} or \co{RESTORESTATE} command.
\end{note}

\subsection{\co{RESTORESTATE} Command}

The \co{RESTORESTATE} command clears and restores visible working
memory and the active conflict set to the state recorded in a
file produced by the \co{SAVESTATE} command. Suppose you used the
\co{SAVESTATE} command to copy the state of working memory and the
conflict set to the file \co{MY\_SAVE.DAT}. The following command
restores working memory and the conflict set to the state
recorded in the file \co{MY\_SAVE.DAT}:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{restorestate my_save.dat}
\end{Verbatim}
\end{quote}

The \co{RESTORESTATE} command:

\begin{itemize}
\item Clears visible working memory.
\item Clears the active conflict set.
\item Restores working memory from the saved state Saved WMOs that are
  not visible to the active entry block are ignored.
\item Restores the conflict set from the saved state.

  Saved conflict set information that does not pertain to the active
  entry block is ignored.
\end{itemize}

The \co{RESTORESTATE} command automatically performs ID translation on
any \co{INSTANCE-ID} values stored in attributes of the saved
WMOs. That is, if you use IDs as pointers the relationships among
saved WMOs are maintained. (See the description of
\verb|rul_start_id_translation| in Chapter A for details on ID
translation.)

\subsection{\co{ADDSTATE} Command}


\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{addstate my_save.dat}
\end{Verbatim}
\end{quote}

The \co{ADDSTATE} command:

\begin{itemize}
\item Adds the objects in the saved state to visible working memory
  Saved WMOs that are not visible to the active entry block are
  ignored.
\item Adds the instantiations arising from the objects it just made to
  the active conflict set.

  Saved instantiations that do not pertain to the active entry block
  are ignored.
\end{itemize}

Unlike the \co{RESTORESTATE} command, the \co{ADDSTATE} command does not
delete any existing WMOs before creating new ones from the saved
file. Like the \co{RESTORESTATE} command, \co{ADDSTATE} automatically
performs ID translation on the saved WMOs (see
\verb|rul_start_id_translation| in Chapter A for details).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rwug"
%%% End:
