\chapter{RuleWorks Reference Dictionary}

\makeatletter
\newenvironment{operands}
               {\vspace{1ex}\noindent\textbf{Operands}\nopagebreak
                 \list{}{\labelwidth\z@ \itemindent-\leftmargin
                   \topsep=\z@                   
                   \let\makelabel\operandlabel\let\labelsep=\textwidth}}
               {\endlist}

This chapter contains complete descriptions of all constructs in the
RuleWorks language, including tables and complete descriptions. The
following tables, presented at the beginning of this chapter,
summarize the RuleWorks language constructs by category:

\begin{itemize}
\item Operators
\item Predicates and Relational Operators
\item Statements
\item Actions
\item Functions
\item Commands
\item Declarations
\item SQL Interface routines
\end{itemize}

Many of the constructs described in this Reference Dictionary can be
specified with arguments. When you specify argument values, separate
the categories with any combination of spaces, tabs, and carriage
returns.

The descriptions of all constructs are presented after the tables,
alphabetically by name, with the non-alphabetic operators and
predicates at the beginning. The descriptions include:

\begin{itemize}
\item usage details
\item syntax
\item format
\item arguments
\item examples
\end{itemize}

Note: you cannot use expressions that contain variables or function
calls (except the \co{COMPOUND} function) as argument values for
commands.

The RuleWorks run-time library routines are described in Appendix A.

\section{Summary of Operators}

\subsubsection{Summary of Operators---Arithmetic Operators}

\begin{tabularx}{\columnwidth}{cX}
  \toprule
  Operator & Description \\
  \midrule
  \co{+} & Performs addition on numeric values \\
  \co{-} & Performs subtraction on numeric values \\
  \co{*} & Performs multiplication on numeric values \\
  \co{/} & Performs division on numeric values \\
  \co{\textbackslash} & Performs the modulus operation on integer value \\
  \bottomrule
\end{tabularx}

\subsubsection{Summary of Operators---Match Operators}

\begin{tabularx}{\columnwidth}{cX}
  \toprule
  Operator & Description \\
  \midrule
  \ct & Specifies an attribute of an object \\
  \co{\{} \co{\}} & Specifies a conjunction (logical AND) of values \\
  \co{<<} \co{>>} & Specifies a disjunction (logical OR)
                    between values \\
  \bottomrule
\end{tabularx}
  
\subsubsection{Summary of Operators - Logical Operators*}

  \begin{tabularx}{\columnwidth}{cX}
    \toprule
    Operator & Description\\
    \midrule
    \co{AND} & Performs a conjunction on two relational expressions \\
    \co{NOT} & Negates a relational expression\\
    \co{OR} & Performs an inclusive disjunction on two 
              relational expressions \\
    \bottomrule
  \end{tabularx}

\begin{note}
  Logical operators can be used only within the context of
  \co{IF}\ldots\co{THEN}\ldots\co{ELSE}\ldots{} and
  \co{WHILE}\ldots\co{DO}\ldots{} actions.
\end{note}

\section{Summary of Predicates and Relational Operators}

Scalar predicates are those that are valid only for scalar
attributes. The exceptions are identity and nonidentity (\co{==} and
\co{<>}, which are also valid for comparing a compound attribute to a
compound value. Compound predicates are those that are valid for
compound attributes.

\subsubsection{Summary of Scalar Predicates and Relational Operators}

\begin{tabularx}{\columnwidth}{cccX}
  \toprule
  Domain & Predicate & Value Domain & Test \\
  \midrule
  ANY & \co{==} & ANY & Identity: Same type as and equal to.
                        This predicate is optional in
                        LHS attribute-value tests. It is required
                        in RHS relational expressions. \\
  ANY & \co{<>} & ANY & Nonidentity; converse of identity \\
  ANY & \co{=}  & ANY & Equality: Identical or equivalent numbers;
                        identical symbols except for case;
                        identical values of all other 
                        data types                      \\
  ANY & \co{-=} & ANY & Inequality; converse of   
                        equality \\
  ANY & \co{\textasciitilde=} & ANY & Similarity: Equal or phonetically
                                      similar symbols; equal or
                                      approximately equal  numbers; 
                                      identical values of all other
                                      data types \\
  ANY & \co{-\textasciitilde=} & ANY & Dissimilarity; converse of similarity \\
  NUMBER & \co{>} & NUMBER & Greater than \\
  SYMBOL & \co{>} & SYMBOL & Lexicographically after \\
  ANY    & \co{>=} & ANY & Greater than or equal numbers;
                           lexicographically after or  equal symbols;
                           identical values for all other data types \\
  NUMBER & \co{<} & NUMBER & Less than \\
  SYMBOL & \co{<} & SYMBOL & Lexicographically before \\
  ANY    & \co{<=} & ANY & Less than or equal numbers;
                           lexicographically before or equal symbols;
                           identical values  for all other data types \\
  ANY & \co{<=>} & ANY & Same type \\
  ANY & \co{<->} & ANY & Different type \\
  \bottomrule
\end{tabularx}

\subsubsection{Summary of Compound Predicates and Relational Operators}

\begin{tabularx}{\columnwidth}{cccX}
  \toprule
  Domain & Predicate & Value Domain & Test \\
  \midrule
  COMPOUND & \co{[+]} & ATOM & Containment; compound contains atom \\
  COMPOUND & \co{[-]} & ATOM & Non-containment; converse of containment \\
  COMPOUND & \co{[=]} & INTEGER & Length equal \\
  COMPOUND & \co{[<>]} & INTEGER & Length not equal \\
  COMPOUND & \co{[>]} & INTEGER & Length greater \\
  COMPOUND & \co{[>=]} & INTEGER & Length greater than or  equal \\
  COMPOUND & \co{[<]}  & INTEGER & Length less than \\
  COMPOUND & \co{[<=]} & INTEGER & Length less than or equal \\
  \bottomrule
\end{tabularx}

\section{Summary of Statements}

Rules and catchers may be contained in either an entry block or a
rule block, but \co{ON-} statements must be contained in an entry
block.

\begin{tabularx}{\columnwidth}{lX}
  \toprule
  Statement & Description \\
  \midrule
  \co{CATCH} & Contains actions that are executed after a 
               specified number of recognize-act cycles (see    
               also the \co{AFTER} action) \\
  \co{ON-EMPTY} & Contains actions that are executed when the
                  conflict set is empty \\
  \co{ON-ENTRY} & Contains actions that are executed when the entry
                  block is called, before the first recognize-act
                  cycle \\
    \co{ON-EVERY} & Contains actions that are executed after the act 
                    phase of each recognize-act cycle except the last  \\
  \co{ON-EXIT} &  Contains actions that are executed after the act 
                 phase of the last recognize-act cycle, except    
                 when a \co{QUIT} action is performed \\
  \co{RULE} & Contains actions that are executed when 
              left-hand-side conditions are met and the 
              instantiation wins conflict resolution \\
  \bottomrule
\end{tabularx}

\section{Summary of Actions}

\begin{longtable}{p{4cm}p{11cm}}
  \toprule
  Action & Description \\
  \midrule
  \co{ADDSTATE} & Adds the contents of a file produced by the \co{SAVESTATE}
                  action or command to the current state of working memory
                  and the conflict set \\\addlinespace
  \co{AFTER} & Specifies the number of recognize-act cycles that must be
               executed before a specified
               catcher is executed \\\addlinespace
  \co{BIND} & Binds a variable to a value \\\addlinespace
  \co{CLOSEFILE} & Closes the open files associated with specified file
                   identifiers and dissociates the
                   identifiers from the files \\\addlinespace
  \co{COPY} & Copies a new copy of an existing object \\\addlinespace
  \co{DEFAULT} & Sets the terminal or a file as the default
                 input source for the \co{ACCEPT-ATOM} and         
                 \co{ACCEPTLINE-COMPOUND} functions, or the default 
                 output destination for the \co{WRITE} action or for
                 trace output  \\
  \co{FOR-EACH} & Iterates over a compound value, executing the 
                  specified actions \\\addlinespace
  \co{IF}\ldots\co{THEN}\ldots\co{ELSE}\ldots & Provides a branch in the flow of control, as 
                                                in procedural languages \\\addlinespace
  \co{MAKE} & Creates an object \\\addlinespace
  \co{MODIFY} & Changes one or more values in an existing
                object \\\addlinespace
  \co{OPENFILE} & Opens a file and associates it with a file
                  identifier \\\addlinespace
  \co{QUIT} & Stops execution of the active entry block and
              passes control back to the operating system,
              optionally returning a value \\\addlinespace
  \co{REMOVE} & Deletes one or more objects \\\addlinespace
  \co{REMOVE-EVERY} & Deletes all the working memory objects that  
                      are instances of the specified class or its  
                      subclasses \\\addlinespace
  \co{RESTORESTATE} & Clears and then restores working memory and  
                      the conflict set to the state recorded in a  
                      file produced by the \co{SAVESTATE} action or     
                      command  \\\addlinespace
  \co{RETURN} & Stops execution of the active entry block,    
                executes the \co{ON-EXIT} actions (if any), and    
                passes control back to the caller of the entry
                block. May also pass a return value. \\\addlinespace
  \co{SAVESTATE} & Copies the state of working memory and the    
                   conflict set to a file \\\addlinespace
  \co{SPECIALIZE} & Converts an instance of one class to an 
                    instance of a descendent class  \\\addlinespace
  \co{TRACE} & Displays or sets the run-time system's trace  
               setting \\\addlinespace
  \co{WHILE}\ldots\co{DO}\ldots & Provides a loop in the flow of control, as in
                                  procedural languages \\\addlinespace
  \co{WRITE} & Sends output from a program to the terminal or
               a file \\
  \bottomrule
\end{longtable}

\section{Summary of Functions}

\begin{longtable}{p{3.8cm}p{2.5cm}p{8.7cm}}
  \toprule
  Function & \raggedright OK on LHS? & Description \\
  \midrule
  \co{ACCEPT-ATOM} & No & Reads an atom from the terminal  or a file \\\addlinespace
  \co{ACCEPTLINE-COMPOUND} & No & Reads a line of input from the terminal or file into a compound value \\\addlinespace
  \co{COMPOUND} & Yes & Creates a new compound value from any number of arguments, scalar or compound \\\addlinespace
  \co{CONCAT} & Yes & Concatenates the print forms of its arguments \\\addlinespace
  \co{CRLF} & No & Causes the \co{WRITE} action to produce output on a new line  \\\addlinespace
  \co{EVERY} & No & Returns a compound value that contains the IDs of all instances of the specified class \\\addlinespace
  \co{FLOAT} & Yes & Converts a numeric value into a floating-point number \\\addlinespace
  \co{GENATOM} & No & Returns a system-generated atom \\\addlinespace
  \co{GET} & No & Given a variable bound to an object identifier and an attribute name, returns the value of that object's attribute \\\addlinespace
  \co{INTEGER} & Yes & Converts a numeric value into an integer \\\addlinespace
  \co{IS-OPEN} & No & Tests whether a file is open \\\addlinespace
  \co{LENGTH} & Yes & Returns the number of elements in a compound value \\\addlinespace
  \co{MAX} & Yes &  Returns the largest of its arguments \\\addlinespace
  \co{MIN} & Yes & Returns the smallest of its  arguments \\\addlinespace
  \co{NTH} & Yes & Returns the value of a specified element in a compound value \\\addlinespace
  \co{POSITION} & Yes & Finds the first occurrence of  an element in a compound value \\\addlinespace
  \co{RJUST} & No & Causes the \co{WRITE} action to right justify output in a field of specified width \\\addlinespace
  \co{SUBCOMPOUND} & Yes & Returns a subrange of a compound value \\\addlinespace
  \co{SUBSYMBOL} & Yes & Returns a fragment of a symbolic value \\\addlinespace
  \co{SYMBOL} & Yes & Converts any atom into a symbol \\\addlinespace
  \co{TABTO} & No & Causes the \co{WRITE} action to put output in a specified column \\
  \bottomrule
\end{longtable}

\section{Summary of Commands}

\begin{longtable}{p{4cm}p{11cm}}
  \toprule
  Command & Description \\
  \midrule
  \verb|@| & Opens a file containing RuleWorks commands and
             executes the commands. \\\addlinespace
  \co{ADDSTATE} & Adds the contents of a file produced by the
                  \co{SAVESTATE} action or command to the current
                  state of working memory. \\\addlinespace
  \co{AFTER} & Specifies the number of recognize-act cycles
               that must be executed before a specified
               catcher is executed. \\\addlinespace
  \co{CLOSEFILE} & Closes the open files associated with 
                   specified file identifiers and dissociates the 
                   identifiers from the files. \\\addlinespace
  \co{COPY} & Makes a new copy of an existing object. \\\addlinespace
  \co{CS} & Displays the current contents of the conflict 
            set. \\\addlinespace
  \co{DEFAULT} & Sets the terminal or a file as the default 
                 input source for the \co{ACCEPT-ATOM} and 
                 \co{ACCEPTLINE-COMPOUND} functions, or the default
                 output destination for the \co{WRITE} action or 
                 trace output. \\\addlinespace
  \co{DISABLE} & Disables the \co{WMHISTORY} command and the display
                 of block names. \\\addlinespace
  \co{EBREAK} & Displays entry blocks that have breakpoints 
                set, sets breakpoints for entry blocks, or 
                deletes breakpoints from entry blocks. \\\addlinespace
  \co{ENABLE} & Enables the \co{WMHISTORY} command and the display  
              of block names. \\\addlinespace
  \co{EXIT} & Synonym for \co{QUIT} command. \\\addlinespace
  \co{MAKE} & Creates a working-memory object. \\\addlinespace
  \co{MATCHES} & Displays the identifiers and time-tags of 
                 objects that match condition elements in a 
                 specified rule. \\\addlinespace
  \co{MODIFY} & Changes one or more values in an existing 
              working-memory object. \\\addlinespace
  \co{NEXT} & Displays the instantiation the run-time system 
              will select from the conflict set for the act  
              phase of the next recognize-act cycle. \\\addlinespace
  \co{OPENFILE} & Opens a file and associates it with a file 
                  identifier. \\\addlinespace
  \co{PPCLASS} & Displays the ancestors of an object class. \\\addlinespace
  \co{PPWM} & Displays working-memory objects that match a 
              specified pattern. \\\addlinespace
  \co{QUIT} & Stops execution and returns control to the 
              operating system; optionally returns an 
              integer value. \\\addlinespace
  \co{RBREAK} &  Displays rules that have breakpoints set, sets
                breakpoints for rules, or deletes breakpoints
                from rules. \\\addlinespace
  \co{REMOVE} & Deletes objects from working memory. \\\addlinespace
  \co{REMOVE-EVERY} & Deletes all working-memory objects that are 
                      instances of a specified class or subclass. \\\addlinespace
  \co{RESTORESTATE} & Clears working memory and the conflict set,
                      then loads them from a file produced by the 
                      \co{SAVESTATE} action or command. \\\addlinespace
  \co{RETURN} & Passes control back to the caller of the entry
                block; optionally returns a value. \\\addlinespace
  \co{RUN} & Executes recognize-act cycles. \\\addlinespace
  \co{SAVESTATE} & Copies the state of working memory and the 
                   conflict set to a file. \\\addlinespace
  \co{SPECIALIZE} & Changes a working-memory object from an 
                    instance of one class to an instance of a 
                    parent class. \\\addlinespace
  \co{TRACE} & Displays or sets the amount of debugging 
               information displayed by the run-time system. \\\addlinespace
  \co{WBREAK} & Displays objects that have breakpoints set, 
                sets breakpoints for objects, or deletes 
                breakpoints from objects. \\\addlinespace
  \co{WM} &  Displays working-memory objects. \\\addlinespace
  \co{WMHISTORY} & Displays the revision history of an object. \\
  \bottomrule
\end{longtable}

\section{Summary of Declarations}

\begin{longtable}{p{4cm}p{11cm}}
  \toprule
  Declaration & Description \\
  \midrule
  \co{DECLARATION-BLOCK} & Begins a set of shareable object class  
                           and external routine declarations \\\addlinespace
  \co{END-BLOCK} & Ends an entry, declaration, or rule block \\\addlinespace
  \co{END-GROUP} & Ends a rule group \\\addlinespace
  \co{ENTRY-BLOCK} & Begins a callable RuleWorks routine \\\addlinespace
  \co{EXTERNAL-ROUTINE} & Declares a routine written in a language 
                          other than RuleWorks, or another 
                          RuleWorks entry block \\\addlinespace
  \co{OBJECT-CLASS} & Defines a class name and its list of 
                      attribute names \\\addlinespace
  \co{RULE-BLOCK} &  Begins a set of shareable rules and 
                    catchers \\\addlinespace
  \co{RULE-GROUP} & Begins a named set of rules and catchers \\
  \bottomrule
\end{longtable}


\section{Summary of SQL Actions}

\begin{longtable}{p{5cm}p{10cm}}
  \toprule
  Action & Description \\
  \midrule
  \co{SQL-ATTACH} & Specifies the database that is to be
                    accessed by the other RuleWorks SQL
                    actions. \\\addlinespace
  \co{SQL-COMMIT} & Completes the current SQL 
                    transaction and makes permanent any 
                    changes made during the transaction. \\\addlinespace
  \co{SQL-DELETE} & Deletes specified records from the 
                    database. \\\addlinespace
  \co{SQL-DETACH} & Commits any outstanding transaction
                    and detaches from the database. \\\addlinespace
  \co{SQL-FETCH-EACH} & Binds field values to RuleWorks 
                        variables and executes RuleWorks 
                        actions that can use those 
                        variables. \\\addlinespace
  \co{SQL-FETCH-AS-OBJECT} & Makes objects from database records. \\\addlinespace
  \co{SQL-INSERT} & Stores new records in the database. \\\addlinespace
  \co{SQL-INSERT-FROM-OBJECT} & Stores the contents of an object in
                                a new database record. \\\addlinespace
  \co{SQL-ROLLBACK} & Completes the current SQL 
                      transaction and undoes any changes
                      made during the transaction. \\\addlinespace
  \co{SQL-START} & Starts an SQL transaction and sets 
                   transaction options. \\\addlinespace
  \co{SQL-UPDATE} & Modifies existing database records. \\\addlinespace
  \co{SQL-UPDATE-FROM-OBJECT} & Modifies existing database records,
                                using the contents of an object. \\
  \bottomrule
\end{longtable}

\section{Operator Descriptions}

This section contains a description of the RuleWorks operators,
in alphabetical order.

\subsection{\co{+} (Addition)}

Performs arithmetic addition on numeric values.

\Format

\it{numeric-expression} \co{+} \it{numeric-expression}

\begin{operands}
\item[numeric-expression] The numeric expressions to be
  added. These may be numeric constants, arithmetic expressions,
  variables bound to numeric values, or functions that return numeric
  values.
\end{operands}

\Example

The following action shows addition of a bound variable and a
constant.

\begin{quote}
\begin{verbatim}
(modify <the-counter> ^count ( <c> + 1 ) )
\end{verbatim}
\end{quote}

\subsection{\co- (Negation and Subtraction)}

\textsc{As a Match Operator}

Negates a condition element (see Chapter~\ref{c:conditionelements} for
a discussion of negative CEs).

\Format

\co- \it{condition-element}

\begin{operands}
\item[condition-element] The CE that is to be negated.
\end{operands}

\textsc{As an Arithmetic Operator}

Performs arithmetic subtraction on numeric values.

\Format

\co- \it{numeric-expression}

\it{numeric-expression} \co- \it{numeric-expression}

\begin{operands}
\item[numeric-expression]

  The numeric expressions to be subtracted. These arguments may be
  numeric constants, arithmetic expressions, variables bound to
  numeric values, or functions that return numeric values.
\end{operands}
  
\Example

The following two CEs test for the existence of one and only one
object of class \co{MEMORY}:

\begin{quote}
\begin{verbatim}
(memory ^$ID <the-mem>)
-(memory ^$ID <> <the-mem>)
\end{verbatim}
\end{quote}

The following action shows subtraction of a bound variable
and a constant:

\begin{quote}
\begin{verbatim}
(write (crlf) |Read| ( <c> - 1 ) |items from input.| (crlf))
\end{verbatim}
\end{quote}

\subsection{\co* (Multiplication)}

Performs arithmetic multiplication on numeric values.

\Format
\it{numeric-expression} * \it{numeric-expression}

\begin{operands}
\item[numeric-expression]
  The numeric expressions to be multiplied. These may be numeric
  constants, arithmetic expressions, variables bound to numeric
  values, or functions that return numeric values.
\end{operands}

\Example

If the \co{KIWI.RUL} program calculates sales tax, it can use the
following action:

\begin{quote}
\begin{verbatim}
(modify <the-total> ^cost (<cost> + (<cost> * <tax>)))
\end{verbatim}
\end{quote}


\subsection{\co/ (Division)}

Performs arithmetic division on numeric values.

\Format
\it{numeric-expression} \co/ \it{numeric-expression}

\begin{operands}
\item[numeric-expression]

  The numeric expressions to be divided. These may be numeric
  constants, arithmetic expressions, variables bound to numeric
  values, or functions that return numeric values.

  The second operand must not evaluate to zero, or a warning is
  generated and the result is zero. The result is an integer only when
  both operands are integers.
\end{operands}

\Example 

The following action converts degrees Fahrenheit to degrees Celsius:

\begin{quote}
\begin{verbatim}
(bind <degrees-c> ((<degrees-f> - 32) * 5 / 9))
\end{verbatim}
\end{quote}

Note that the entire arithmetic expression must be enclosed in
parentheses.

\subsection{\co\textbackslash{} (Modulus)}

Performs the arithmetic modulus operation on integer values.

\Format

\it{integer-expression} \co{\textbackslash} \it{integer-expression}

\begin{operands}
\item[integer-expression]

  The dividend and divisor for the modulus operation. These may be
  integers, arithmetic expressions that evaluate to integers,
  variables bound to integers, or functions that return integers.
\end{operands}

\Example

The following rule uses both division and modules on integers:

\begin{quote}
\begin{verbatim}
(rule find-dozens
    (start ^$ID <start>)
  -->
    (write (crlf) |Enter an integer: | )
    (bind <eggs> (accept-atom))
    (write (crlf) |There are| (<eggs> / 12) |dozen in|<eggs>) ; division
    (write (crlf) | and there are| (<eggs> 12) |left over|) ; modulus
    (modify <start>))
\end{verbatim}
\end{quote}

This example produces the following output:

\begin{quote}
\begin{verbatim}
Enter an integer: 13
There are 1 dozen in 13
and there are 1 left over
Enter an integer: 39
There are 3 dozen in 39
and there are 3 left over
Enter an integer:
\end{verbatim}
\end{quote}

\subsection{\co{\^} (Attribute)}

Specifies an attribute of an object. You must define all attributes in
an \co{OBJECT-CLASS} declaration. For more information about
attributes, see Chapter~\ref{c:workingmem}.

\Format

\ct\it{attribute-name}

\begin{arguments}
\item[attribute-name] The name of a declared attribute.

  In condition elements on the LHS, this argument must be a symbolic
  atom. In actions on the RHS, this argument can be a symbol or a
  variable that is bound to a declared attribute name.
\end{arguments}

\Example

The following \co{OBJECT-CLASS} declaration defines the attribute
\co{\^{}ITEM} for the class \co{INPUT-THING}:

\begin{quote}
\begin{verbatim}
(object-class input-thing
    ^item)
\end{verbatim}
\end{quote}

The following CE matches objects of class \co{INPUT-THING} whose
\co{\^{}ITEM} attribute has the value \co{HOME-KIWI}. It also uses the
built-in attribute \co{\^\$ID} to bind an object variable:

\begin{quote}
\begin{verbatim}
(input-thing ^item home-kiwi ^$ID <my-input-thing>)
\end{verbatim}
\end{quote}

\subsection{\co{==} (Identity)}

Produces a match, or evaluates to true, when both its operands have
the same type and the same value.

Two compound values are identical if they contain the same values in
the same order.

\textsc{As a Match Predicate}

In an attribute-value test on the LHS, the identity predicate is
optional.

If the value following the identity predicate is an unbound variable,
that variable is bound to the value of the specified attribute. The
identity and length-equal (\co{[=]}) predicates are the only
predicates that can precede the first occurrence of a variable,
because they are the only ones that can either bind a variable or
compare its value.

\Format

\co{\^}\it{attribute} \co{==} \it{value-expression}

\co{\^}\it{attribute} \it{value-expression}

\textsc{As a Relational Operator}
\nopagebreak

In a relational expression on the RHS, the identity operator is
required. There is no default or implied operator inside relational
expressions.

\Format

\it{value-expression} \co{==} \it{value-expression}

\begin{operands}
\item[\ct attribute]

  An attribute of a WMO whose value is to be tested.

\item[value-expression]

  Any RuleWorks expression, whose value is to be tested.
\end{operands}

\Example

The following CE uses the implied identity predicate:

\begin{quote}
\begin{verbatim}
(active-context ^name verify-configuration)
\end{verbatim}
\end{quote}

The relational expression below, of necessity, uses the explicit
identity predicate:

\begin{quote}
\begin{verbatim}
(if ((is-open infile) = = nil)
 then (openfile infile orders.dat in))
\end{verbatim}
\end{quote}

\subsection{\co{<>} (Nonidentity)}

Produces a match when the identity predicate (see previous fails to
match; evaluates to true when the identity operator evaluates to
false.

\Example

The following two CEs test for the existence of one and only
one object of class \co{MEMORY}:

\begin{quote}
\begin{verbatim}
(memory ^$ID <the-mem>)
-(memory ^$ID <> <the-mem>)
\end{verbatim}
\end{quote}

\subsection{\co= (Equality)}

Produces a match, or evaluates to true, when its operands are
identical or have equal values.

The equality predicate and operator performs automatic type conversion
between \co{INTEGER} and \co{FLOAT} values. For example, 2 is equal to 2.0, but
2 is not identical to 2.0.

The equality predicate and operator ignores case when comparing SYMBOL
values. For example, \co{|cat |} is equal to \co{CAT}, but \co{|cat |}
is not identical to \co{CAT}.

You cannot use the equality predicate with the binding instance of a
variable. You must use the identity predicate.

\Format

\co{\^}\it{attribute} \co= \it{value-expression}

\begin{operands}
\item[\ct attribute]

  An attribute of a WMO whose value is to be tested.

\item[value-expression]

  Any RuleWorks expression, whose value is to be tested.
\end{operands}

\Example

The following CE uses the less restrictive equality predicate:

\begin{quote}
\begin{verbatim}
(active-context ^name = verify-configuration)
\end{verbatim}
\end{quote}

\subsection{\co{-=} (Inequality)}

Produces a match when the equality predicate (see previous page) fails
to match; evaluates to true when the equality operator evaluates to
false.

\Example
This attribute-value test is the converse of the previous
example:
\begin{quote}
\begin{verbatim}
(active-context ^name -= verify-configuration)
\end{verbatim}
\end{quote}


\subsection{\co{\~{}=} (Similarity)}

Produces a match, or evaluates to true, when its arguments are either
both numbers or the same type, and are similar to each
other. Similarity is defined as follows:

Two numbers are considered to be similar when the difference between
their values is less than or equal to 1 percent of the larger absolute
value. Like the equality predicate, the similarity predicate
automatically converts between the \co{INTEGER} and \co{FLOAT} data types.

Two symbols are similar when one of the following is true:

They are identical or equal (equality is independent of case).

Both symbols are at least three characters long, and adding a single
character to one symbol makes it equal to the other.

Both symbols are at least three characters long, and transposing two
characters in one symbol makes it equal to the other.

They have identical SOUNDEX values.

SOUNDEX values are calculated according to an algorithm similar to
that published in \emph{The Art of Computer Programming}, Volume 3,
pages 391--392, by Donald Knuth.  The English-language rules are as
follows:

\begin{enumerate}
\item Find the first alphabetic character in the symbol, and convert
  it to uppercase.
\item Convert all non-alphabetic characters to a code of 0.
\item Ignoring case, replace each consonant (after the first
  alphabetic character), except H's and W's, with its corresponding
  consonant group code number:

  B, F, P, V    1

  C, G, J, K, Q, S, X, Z  2

  D, T    3

  L     4

  M, N    5

  R     6
\item If two or more adjacent characters contain the same code, remove
  all but the first.
\item Ignoring case and leaving the first alphabetic character, remove
  all the vowels (including Y), H's, and W's, and all remaining zeroes
  and spaces.
\end{enumerate}

For all other data types, similarity is the same as identity.  For
example, assuming \co{<the-id>} is already bound, the two
attribute-value tests shown below match under the same circumstances:

\begin{quote}
\begin{verbatim}
^$ID == <the-id>
^$ID ~= <the-id>
\end{verbatim}
\end{quote}

The identity predicate is more efficient.

You cannot use the similarity predicate with the binding instance of a
variable.

\Format

\ct\it{attribute} \co{\~{}=} \it{value-expression}

\it{value-expression} \co{\~{}=} \it{value-expression}

\begin{operands}
\item[\ct{attribute}]

  An attribute of a WMO whose value is to be tested.

\item[value-expression]

  Any RuleWorks expression, whose value is to be tested.
\end{operands}

\Example

The first table shows the results of several similarity tests on
numbers:

\begin{center}
\begin{tabular}{lll}
  \toprule
  First Value & Second Value & Similar? \\
  \midrule
  4.0        & 4            & Yes \\
  4.5        & 4            & No \\
  9.9      & 10           & Yes \\
  -9.9     &   -10          & Yes \\
  \bottomrule
\end{tabular}
\end{center}

The next table shows the SOUNDEX codes of several symbols.  Note that
the last three codes match exactly:

\begin{center}
\begin{tabular}{ll}
  \toprule
  Symbol      & SOUNDEX Code \\
  \midrule
  Tracy       & T62          \\
  Larry       & L6           \\
  St. Laurent & S34653       \\
  Steven      & S315         \\
  Stephen     & S315         \\
  Stefano     & S315         \\
  \bottomrule
\end{tabular}
\end{center}

\subsection{\co{-\~{}=} (Dissimilarity)}

Produces a match, or evaluates to true, when the similarity predicate
(see previous fails to match, or evaluates to false.

\Example

The table below shows the results of several dissimilarity tests:

\begin{center}
\begin{tabular}{lll}
  \toprule
  First Value & Second Value & Dissimilar? \\
  \midrule
  4.0         & 4            & No          \\
  4.5         & 4            & Yes         \\
  9.9         & 10           & No          \\
  -9.9        & -10          & No          \\
  \bottomrule
\end{tabular}
\end{center}

\subsection{\co> (Greater-than)}

Produces a match, or evaluates to true, when its first operand is
greater than its second. The operands must be either both numbers or
both symbols.

See Appendix E for information on the collating sequences used by
RuleWorks to compare symbolic values.

\Format

\ct\it{attribute} \co> \it{value-expression}

\it{value-expression} \co> \it{value-expression}

\begin{operands}
\item[\ct{attribute}]

  An attribute of a WMO whose value is to be tested.

\item[value-expression]

  Any RuleWorks expression that evaluates to a symbol or a number.
\end{operands}

\Example

The following table shows the results of several greater-than tests

\begin{center}
\begin{tabular}{lcll}
  \toprule
  First Value      &   & Second Value & Match or True? \\
  \midrule
  4.0              & \verb|>| & 3            & Yes            \\
  4                & \verb|>| & 5.0          & No             \\
  aardwolf         & \verb|>| & aardvark     & Yes            \\
  \verb,|, greater-than \verb,|, & \verb|>| & greater-than & No             \\
  \bottomrule
\end{tabular}
\end{center}

\subsection{\co{>=} (Greater-than-or-equal)}

Produces a match, or evaluates to true, when its first operand is
greater than or equal to its second. The operands must be either both
numbers or both symbols.

See Appendix E for information on the collating sequences used by
RuleWorks to compare symbolic values.

\Format

\ct\it{attribute} \co{>=} \it{value-expression}

\it{value-expression} \co{>=} \it{value-expression}

\begin{operands}

\item[\ct{attribute}]

  An attribute of a WMO whose value is to be tested.

\item[value-expression]

  Any RuleWorks expression that evaluates to a symbol or a number.
\end{operands}

\Example

The following table shows the results of several greater-than-or-equal
tests:

\begin{center}
\begin{tabular}{lcll}
  \toprule
  First Value      &    & Second Value & Match or True? \\    
  \midrule
  5.0              & \verb|>=| & 5            & Yes            \\
  6                & \verb|>=| & 7.0          & No             \\
  aardvark         & \verb|>=| & Aardvark     & Yes            \\
  \verb,|, greater-than \verb,|, & \verb|>=| & greater-than & Yes            \\
  \bottomrule
\end{tabular}
\end{center}

The aardvarks match because they are equal, which is a case
insensitive comparison, not because the first value is greater than
the second.

\subsection{\co< (Less-than)}

Produces a match, or evaluates to true, when its first operand is less
than its second. The operands must be either both numbers or both
symbols.

See Appendix E for more information on the collating sequences used by
RuleWorks to compare symbolic values.

\Format

\co{\^}\it{attribute} \co< \it{value-expression}

\it{value-expression} \co< \it{value-expression}

\begin{operands}
\item[\ct attribute]

  An attribute of a WMO whose value is to be tested.

\item[value-expression]

  Any RuleWorks expression that evaluates to a symbol or a number.
\end{operands}

\Example

The following table shows the results of several less-than tests:

\begin{center}
\begin{tabular}{lcll}
  \toprule
  First Value &   & Second Value & Match or True? \\
  \midrule
  2.0         & \verb|<| & 3            & Yes \\
  5           & \verb|<| & 6.0          & Yes \\
  zygosis     & \verb|<| & zygote       & Yes \\
  zoology     & \verb|<| & Zoology      & No \\
  \bottomrule
\end{tabular}
\end{center}

\subsection{\co{<=} (Less-than-or-equal)}

Produces a match or evaluates to true, when its first operand is less
than or equal to its second. The operands must be either both numbers
or both symbols.

See Appendix E for information on the collating sequences used by
RuleWorks to compare symbolic values.

\Format

\co{\^}\it{attribute} \co{<=} \it{value-expression}

\it{value-expression} \co{<=} \it{value-expression}

\begin{operands}
\item[\ct{attribute}]

  An attribute of a WMO whose value is to be tested.

\item[value-expression]

  Any RuleWorks expression that evaluates to a symbol or a number.
\end{operands}

\Example

The following table shows the results of several less-than-or equal
tests:

\begin{center}
\begin{tabular}{lcll}
  \toprule
  First Value &   & Second Value & Match or True? \\
  \midrule
  2.0         & \verb|<=| & 3            & Yes \\
  5           & \verb|<=| & 5.0          & Yes \\
  zygosis     & \verb|<=| & zygote       & Yes \\
  zoology     & \verb|<=| & Zoology      & Yes \\
  \bottomrule
\end{tabular}
\end{center}

The symbols match because they are equal, which is a case insensitive
comparison, not because the first value is less than the second.

\subsection{\co{<=>} (Same Type)}

Produces a match, or evaluates to true, when both its operands are the
same type. The RuleWorks data types are \co{INTEGER}, \co{FLOAT},
\co{SYMBOL}, \co{INSTANCE-ID}, and \co{OPAQUE}.

For example, if you specify this predicate with a symbol or a variable
bound to a symbol, a match is produced when the atom in the WMO is a
symbol.

The same-type predicate can be applied to scalar values only.

\Format

\ct\it{attribute} \co{<=>} \it{value-expression}

\it{value-expression} \co{<=>} \it{value-expression}

An attribute of a WMO whose value is to be tested.

\begin{arguments}
\item[value-expression]
  
  Any RuleWorks expression, whose value is to be tested.
\end{arguments}

\Example

The following CE matches an object of class \co{INPUT-THING} whose
\ct\co{ITEM} attribute has a symbolic value:

\begin{quote}
\begin{verbatim}
(input-thing ^item <=> symbol)
\end{verbatim}
\end{quote}

\subsection{\co{<->} (Different-type)}

Produces a match when the same-type predicate (see previous page)
fails to match; evaluates to true when the same-type operator
evaluates to false.

This predicate can be applied to scalar values only.

\Example

This CE is the converse of the previous example:

\begin{quote}
\begin{verbatim}
(input-thing ^item <-> symbol)
\end{verbatim}
\end{quote}

\subsection{\co{[+]} (Containment)}

Produces a match, or evaluates to true, when its scalar operand is an
element of its compound operand. That is, you can test whether a
compound contains a scalar value, or you can test whether a scalar
value is contained in a compound.

By default, the containment predicate tests for identity; you can
specify a different test with an optional scalar predicate. The scalar
predicate must appear next to the scalar argument.

\Format

\ct\it{compound-attr} \co{[+]} [\it{predicate}] \it{scalar-value}

\ct\it{scalar-attr} [\it{predicate}] \co{[+]} \it{compound-value}

\it{compound-value} \co{[+]} [\it{predicate}] \it{scalar-value}

\it{scalar-value} [\it{predicate}] \co{[+]} \it{compound-value}

\begin{operands}
\item[\ct{compound-attr}]

  The compound attribute whose value is to be searched for a scalar
  value.

\item[predicate]

  A predicate that specifies the comparison between elements of the
  compound value and the scalar value. This argument is optional; if
  you do not specify a predicate, RuleWorks uses the default identity
  predicate.

  You can use any scalar predicate except containment and
  non-containment.

\item[scalar-value]

  The scalar value for which a compound attribute is to be searched.

\item[\ct{scalar-attr}]

  The scalar attribute for whose value a compound is to be searched.

\item[compound-value]

  The compound value which is to be searched for a scalar value.
\end{operands}

\Example

The following CE matches an object class \co{BOX} whose
\ct\co{CARD-IN-SLOT} attribute contains at least one \co{MEMORY} element:

\begin{quote}
\begin{verbatim}
(box ^card-in-slot <cards> [+] memory)
\end{verbatim}
\end{quote}

The condition shown below is true when \co{MEMORY} is contained by
\co{<CARDS>}:

\begin{quote}
\begin{verbatim}
(memory [+] <cards>)
\end{verbatim}
\end{quote}

The following attribute-value test uses the similarity
predicate in conjunction with the containment predicate:

\begin{quote}
\begin{verbatim}
^list [+] ~= color
\end{verbatim}
\end{quote}

This test matches when the compound value of the \ct\co{LIST}
attribute contains an element similar to \co{COLOR}, such as
\co{COLOUR} or \co{COULEUR}.

\subsection{\co{[-]} (Non-containment)}

Produces a match when the containment predicate (see previous
page) fails to match; evaluates to true when the containment
operator evaluates to false.

\Example

The following two CEs match a WMO of class \co{BOX} whose
\ct\co{CARD-IN-SLOT-OBJ-ID} attribute does not contain the object
whose ID is bound to \co{<THE-MEM>}:

\begin{quote}
\begin{verbatim}
(memory ^$ID <the-mem>)
(box ^card-in-slot-obj-id [-] <the mem>)
\end{verbatim}
\end{quote}

\subsection{\co{[=]} (Length-equal)}

Produces a match, or evaluates to true, when the number of elements in
its compound operand is identical to its numeric operand.

As with identity predicate, the length-equal predicate can be used
with the first appearance of a variable. This binds the variable to
the actual number of elements in the compound attribute.

\Format

\ct\it{compound-attr} \co{[=]} \it{integer-value}

\it{compound-value} \co{[=]} \it{integer-value}

\begin{operands}
\item[\ct{compound-attr}]

  The compound attribute whose length is to be tested.

\item[integer-value]

  The integer value to which the length of a compound value is to be
  compared. This operand may be any expression that evaluates to an
  integer greater than or equal to zero.

\item[compound-value]

  The compound value whose length is to be tested. This operand may be
  any expression that evaluates to a compound value.
\end{operands}

\Example

The CE below matches an object of class \co{BOX} whose
\verb|^CARD-IN-SLOT| attribute is empty:

\begin{quote}
\begin{verbatim}
(box ^card-in-slot [=] 0)
\end{verbatim}
\end{quote}

This CE shows the syntax for testing the compound and binding a
variable:

\begin{quote}
\begin{verbatim}
(box ^card-in-slot {[=] 0 [=] <cards>})
\end{verbatim}
\end{quote}

\subsection{\co{[<>]} (Length-not-equal)}

Produces a match when the length-equal predicate (see previous page)
fails to match; evaluates to true when the length-equal operator
evaluates to false.

\Example

The following CE matches an object of class \verb|BOX| whose
\verb|^CARD-IN-SLOT| attribute is not empty:

\begin{quote}
\begin{verbatim}
(box ^card-in-slot [<>] 0)
\end{verbatim}
\end{quote}

\subsection{\co{[>]} (Length-greater-than)}

Produces a match, or evaluates to true, if the number of elements in
its compound operand is greater than its integer operand.

\Format

\ct\it{compound-attr} \co{[>]} \it{integer-value}

\it{compound-value} \co{[>]} \it{integer-value}

\begin{operands}
\item[ct{compound-attr}]

  The compound attribute whose length is to be tested.

\item[integer-value]

  The integer value to which the length of a compound value is to be
  compared. This operand may be any expression that evaluates to an
  integer greater than or equal to zero.

\item[compound-value]

  The compound value whose length is to be tested. This operand may be
  any expression that evaluates to compound value.
\end{operands}

\Example

The following CE matches an object of class \verb|BOX| whose
\verb|^CARD-In-SLOT| attribute has more than two elements:

\begin{quote}
\begin{verbatim}
(box ^card-in-slot [>] 2)
\end{verbatim}
\end{quote}

\subsection{\co{[>=]} (Length-greater-than-or-equal)}

Produces a match, or evaluates to true, if the number of elements in
its compound operand is greater than or equal to its integer operand.

\Format

\ct\it{compound-attr} \co{[>=]} \it{integer-value}

\it{compound-value} \co{[>=]} \it{integer-value}

\begin{operands}
\item[\ct{compound-attr}]

  The compound attribute whose length is to be tested.

\item[integer-value]

  The integer value to which the length is to be tested. This operand
  may be any expression that evaluates to an integer greater than or
  equal to zero.

\item[compound-value]

  The compound value whose length is to be tested. This operand may be
  any expression that evaluates to a compound value.
\end{operands}

\Example

The following CE matches an object of class \verb|BOX| whose
\verb|^CARD-IN-SLOT| attribute has two or more elements:

\begin{quote}
\begin{verbatim}
(box ^card-in-slot [>=] 2)
\end{verbatim}
\end{quote}

\subsection{\co{[<]} (Length-less-than)}

Produces a match, or evaluates to true, if the number of elements in
its compound operand is less than its integer operand.

\Format

\ct\it{compound-attr} \co{[<]} \it{integer-value}

\it{compound-value} \co{[<]} \it{integer-value}

\begin{operands}
\item[\ct{compound-attr}]

  The compound attribute whose length is to be tested.

\item[integer-value]

  The integer value to which the length of a compound value is to be
  compared. This operand may be any expression that evaluates to an
  integer greater than or equal to zero.

\item[compound-value]

  The compound value whose length is to be tested. This operand may be
  any expression that evaluates to a compound value.
\end{operands}

\Example

The following CE matches an object of class \verb|BOX| whose
\verb|^CARD-IN-SLOT| attribute has fewer than two elements:

\begin{quote}
\begin{verbatim}
(box ^card-in-slot [<] 2)
\end{verbatim}
\end{quote}

\subsection{\co{[<=]} (Length-less-than-or-equal)}

Produces a match, or evaluates to true, if the number of elements in
its compound operand is less than or equal to its integer operand.

\Format

\ct\it{compound-attr} \co{[<=]} \it{integer-value}

\it{compound-value} \co{[<=]} \it{integer-value}

\begin{operands}
\item[\ct{compound-attr}]

  The compound attribute whose length is to be tested.

\item[integer-value]

  The integer value to which the length of a compound value is to be
  compared. This operand may be any expression that evaluates to an
  integer greater than or equal to zero.

\item[compound-value]

  This operand may be any expression that evaluates to a compound
  value.
\end{operands}

\Example

The following CE matches an object of class \verb|BOX| whose
\verb|^CARD-IN-SLOT| attribute has two or fewer elements.

\begin{quote}
\begin{verbatim}
(box ^card-in-slot [<=] 2)
\end{verbatim}
\end{quote}

\subsection{\co\{ \co\} (Conjunction)}

Specifies a conjunction. A conjunction is similar to a logical AND. It
is a left-hand-side pattern containing one or more conditional tests,
all of which a single attribute in an object must satisfy.

For more information about conjunctions, see
Chapter~\ref{c:conditionelements}.

\Format

\verb|{| \it{conditional-test} \ldots\verb|}|

\begin{operands}
\item[conditional-test]

  One or more conditional tests that the value of an attribute in an
  object is to satisfy.
\end{operands}

\Example

The following CE matches teenagers by testing for age greater than or
equal to 13 AND less than 20:

\begin{quote}
\begin{verbatim}
(person ^age { >= 13 < 20 })
\end{verbatim}
\end{quote}

The next CE contains a conjunction of two tests on the length of the
compound attribute \verb|^CARD-IN-SLOT|. The first binds the length to
the variable \verb|<LEN>|. The second tests that the length is less
than 6:

\begin{quote}
\begin{verbatim}
(box ^$ID <the-box> ^card-in-slot <{> [=] <len> [<] 6})
\end{verbatim}
\end{quote}

You can use a conjunction when you want to bind as well as test an
attribute. For example:

\begin{quote}
\begin{verbatim}
(hardware-option ^in-slot { <slot-num> <> NIL })
\end{verbatim}
\end{quote}


\subsection{\co{<<} \co{>>} (Disjunction)}

Specifies a disjunction of values, similar to a logical inclusive
OR. An attribute that matches any one of the values satisfies the
disjunction (see also Chapter~\ref{c:conditionelements}).

\Format

\verb|<<| \it{value-expression} \ldots\verb|>>|

\begin{operands}
\item[value-expression]

  The value that an attribute value in an object is to match.  This
  argument can be a constant, a bound variable, an arithmetic
  expression, or a function call. It must have the same structure as
  the attribute, either scalar or compound.  You can specify one or
  more values.

  A disjunction of values is implicitly preceded by the identity
  predicate (\verb|==|). You cannot use any other predicate with a
  disjunction of values.
\end{operands}

\Example

The following CE contains a disjunction of values:

\begin{quote}
\begin{verbatim}
(input-thing ^item << NIL EOF END-OF-FILE >>)
\end{verbatim}
\end{quote}

The next example shows the syntax for a compound attribute:

\begin{quote}
\begin{verbatim}
(object ^$id <object-1>
        ^integer-attr <I> ^symbol-attr <s> ^compound-attr <c>)
(object ^$id {<object-2> <> <object-1>}
        ^compound-attr << <c>
                          (compound a <s> c)
                          (subcompound <c> 1 ((length <c>) - <I>))
                       >>)
\end{verbatim}
\end{quote}

\subsection{\co{@} (At)}

Opens a file containing RuleWorks commands and executes the
commands. The file must contain only RuleWorks commands. If the file
cannot be opened, the run-time system displays the following message:

\begin{quote}
\begin{verbatim}
<FAC>-W-CANTOPEN, @ - Unable to open file filename for reading
\end{verbatim}
\end{quote}

\Format

\verb|@| \it{filespec}

\begin{arguments}
\item[filespec]

  The file specification for a file containing RuleWorks commands to
  be executed. The restrictions on file specifications vary according
  to operating system; see Section C.1 for details.
\end{arguments}

\Example

The first command illustrates a simple file specification:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{@ init-mem.wm}
\end{Verbatim}
\end{quote}

The command below shows a file specification that includes a pathname,
and must be quoted:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{@ |C:%MEM.COM|}
\end{Verbatim}
\end{quote}

\subsection{\co{ACCEPT-ATOM}}

Reads an atom from the keyboard or a file. Ignores values after a
semicolon (\verb|;|) until the end of the line.

By default, the \co{ACCEPT-ATOM} function reads input from the
keyboard. If you want the function to read input from a file, call the
function with the file identifier of an open input file, or change the
default for input.

\Format

\co{ACCEPT-ATOM} [ \it{file-id} ]

\begin{arguments}
\item[file-id]

  The file identifier of the file from which input is to be read. The
  file must have been opened and associated with the identifier in a
  previous \co{OPENFILE} action or command.

  This argument is optional. If you do not specify a file identifier,
  input is read from the current default for the \co{ACCEPT-ATOM}
  function (set with the \co{DEFAULT} action or command).
\end{arguments}

\ReturnValue

If the argument you specify is not associated with an open file, the
run-time system issues a warning and the function returns the symbol
\co{NIL}.

When the function reads past the end of a file, it returns the symbol
\co{END-OF-FILE}.

\Example

The following \co{MAKE} action uses the \co{ACCEPT-ATOM} function to
create a Working Memory Object (WMO) that contains an atom read from
the file associated with the file identifier \co{INFIL}.

\begin{quote}
\begin{verbatim}
(make input-thing ^item (accept-atom infil))
\end{verbatim}
\end{quote}

\subsection{\co{ACCEPTLINE-COMPOUND}}

Reads a line of input from the keyboard or a file and returns a
compound value that contains the values read. Ignores values after a
semicolon (\verb|;|) until the end of the line.

If some of the atoms in the current line have already been read, the
input line is defined as all the remaining atoms on the current
line. If all the atoms on the current line have been read, the input
line is the next. If the input line contains no atoms, the function
returns the specified default compound value.

By default, the \co{ACCEPTLINE-COMPOUND} function reads input from the
keyboard. If you want the function to read input from a file, call the
function with the file identifier of an open input file, or change the
default for input.

\Format

\co{ACCEPTLINE-COMPOUND} [\it{file-id} [\it{default-compound-value}]]

\begin{arguments}
\item[file-id]

  The file identifier of the file from which input is to be read. The
  file must have been opened and associated with the identifier in a
  previous \co{OPENFILE} action or command.

  This argument is optional. If you do not specify a file identifier,
  input is read from the current default for the
  \co{ACCEPTLINE-COMPOUND} function (set with the \co{DEFAULT} action
  or command).

\item[default-compound-value]

  The compound value to be returned when the function reads a blank
  line. This argument may be a bound compound variable or a function
  call that returns a compound value.

  If you want to specify a default compound value, you must also
  specify a file identifier. If you want to specify a default compound
  value when reading from the default input source, use the symbol
  \co{NIL} for the file identifier.
\end{arguments}

\ReturnValue

A compound value that contains all the atoms on the current input
line. If the input line contains no atoms, the function returns the
specified default compound value.

If the first argument you specify is not associated with an open file,
the run-time system issues a warning and the function returns the
empty compound value.

When the function reads past the end of a file, it returns a compound
value that contains the single element \co{END-OF-FILE}.

\Example

The following actions read a line of input as a compound variable, and
write it one element at a time:

\begin{quote}
\begin{verbatim}
(bind <my-compound> (acceptline-compound))
(for-each <x> in <my-compound>
    (write (crlf) <x>))
\end{verbatim}
\end{quote}
  
\subsection{\co{ADDSTATE}}

Adds the objects in a file produced by the \co{SAVESTATE} action or
command to working memory.

The added objects have new \co{INSTANCE-ID}s and new time-tags. Any
attributes in the added objects that have \co{INSTANCE-ID} values that
point to other added objects are automatically updated so that the
references remain consistent.

The \co{ADDSTATE} action and command is scoped to the entry block; it
creates visible objects only. Trying to add objects whose class
declarations are not visible to the entry block causes a run-time
warning, and the WMOs are not made.

\Format

\co{ADDSTATE} \it{filespec}

\begin{arguments}
\item[filespec]

  A file specification for a file previously produced by the
  \co{SAVESTATE} action or command. See Section C.1 for restrictions
  on file names.
\end{arguments}

\Example

Suppose you use the \co{SAVESTATE} action or command to create the
file \co{CONFIG.DAT}. The following action adds the objects in the
file to working memory:

\begin{quote}
\begin{verbatim}
(addstate config.dat)
\end{verbatim}
\end{quote}

The equivalent command is:
\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{addstate config.dat}
\end{Verbatim}
\end{quote}

On ULTRIX and Digital UNIX systems, the command could be:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{addstate |config.dat|}
\end{Verbatim}
\end{quote}

\subsection{\co{AFTER}}

Specifies the number of recognize-act cycles that must be executed
before a specified catcher is executed (see also
Chapter~\ref{c:program}).

Only one catcher can be active. Thus, the \co{AFTER} action and
command disables the current catcher, if any, before it enables the
new one.

The rule-firing counter is local to the current invocation of the
active entry block. Recognize-act cycles executed by an entry block
called from the entry block that contains the \co{AFTER} and
\co{CATCH} actions are not counted.

\Format

\co{AFTER} \it{cycles} \it{catcher-name}

\begin{arguments}
\item[cycles]

  A positive integer that specifies the number of recognize-act cycles
  that are to be executed before the specified catcher is executed. If
  this number of cycles is never reached, the catcher is not executed.

\item[catcher-name]

  A symbol that names a catcher.

  If the catcher executes another \co{AFTER}, the counter restarts.
\end{arguments}

\Example

The following command specifies that the catcher named
\co{TOO-MANY-CYCLES} is to be executed after 100 recognize-act
cycles have been executed:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{after 100 too-many-cycles}
\end{Verbatim}
\end{quote}

The equivalent action is:

\begin{quote}
\begin{verbatim}
(AFTER 100 TOO-MANY-CYCLES)
\end{verbatim}
\end{quote}

\subsection{\co{AND}}

Performs a logical conjunction on its two operands, that is, returns
true only when both of its operands are true.

\begin{note}
  This is a relational operator only, not a match predicate. \co{AND}
  may be used only in relational expressions within
  \co{IF}\ldots\co{THEN}\ldots\co{ELSE} or
  \co{WHILE}\ldots\co{DO}\ldots{} actions.
\end{note}

\Format

\it{rel-expr} \co{AND} \it{rel-expr}

\begin{operands}
\item[rel-expr]

  The relational expressions to be combined. These arguments must
  evaluate to either true or false.
\end{operands}

\Example

The following code fragment shows the \co{AND} operator in a
\co{WHILE}\ldots\co{DO}\ldots{} action:

\begin{quote}
\begin{verbatim}
(while ((<cards-dealt> < 5) AND (<dealing> == true)) do
       (deal-a-card))
\end{verbatim}
\end{quote}

\subsection{\co{BIND}}

Binds a variable to a value.

The scope of the variable binding depends on the construct that
contains the \co{BIND} action. Variables bound in rules, catchers, and
methods are local. Variables bound to the input arguments of an entry
block, and variables bound in any \co{ON}- statement, are visible to
all subsequent \co{ON}- statements.

\Format

\co{BIND} \it{variable} \it{value-expression}

\begin{arguments}
\item[variable]

  The variable to which a value is to be bound.

\item[value-expression]

  An expression that can evaluate to either a scalar or compound
  value. The action binds the specified variable to the value that
  results from the evaluation.
\end{arguments}

\begin{note}
  \co{MAKE}, \co{COPY}, \co{MODIFY}, and \co{SPECIALIZE} actions
  return a value of type \co{INSTANCE-ID}. You can use them as the
  second argument to the \co{BIND} action, as well as anywhere else a
  value expression is permitted.
\end{note}

\Example

The following action binds the variable \verb|<NEW-OBJECT>| to the
\co{INSTANCE-ID} returned by a \co{MAKE} action. (See
Section~\ref{s:attributevalue} for an example of a complete program):

\begin{quote}
\begin{verbatim}
(bind <new-object>
    (make example-object 
        ^next <first-object> 
        ^last <instance-id>
        ^value (<val> + 1)))
\end{verbatim}
\end{quote}         

\subsection{\co{CATCH}}

Creates a catcher, which is a list of actions that are executed after
a specified number of recognize-act cycles have been executed. An
\co{AFTER} action or command specifies the number of recognize-act
cycles to be executed before the catcher is executed.

The \co{AFTER} and the \co{CATCH} must be contained in the same
block. The recognize-act cycles count includes only rule firings in
the entry block that contains or activates the \co{AFTER} and the
\co{CATCH}.

\Format

\co{CATCH} \it{catcher-name} \it{action}

\begin{arguments}
\item[catcher-name]

  A symbol that names the catcher being created. The symbol cannot be
  the name of another catcher, a rule, a rule group that already exits
  in the entry block.

\item[action]

  Any RHS action. You can specify one or more actions.
\end{arguments}

\Example

The following \co{CATCH} statement creates a catcher named
\co{TOO-MANY-CYCLES}, which displays a message after the number of
recognize-act cycles specified in an \co{AFTER} action or command have
been executed, and stops execution:

\begin{quote}
\begin{verbatim}
(catch too-many-cycles
    (write (crlf) |Program appears to be looping.|)
    (quit))
\end{verbatim}
\end{quote}
     
\subsection{\co{CLOSEFILE}}

Closes the open files associated with specified file identifiers and
dissociates the identifiers from the files.

\Format

\co{CLOSEFILE} \it{file-id} \ldots

\begin{argument}
\item[file-id]

  The file identifier of the file to be closed. The file must have
  been opened and associated with the identifier in a previous
  \co{OPENFILE} action or command.

  You can specify one or more file identifiers.
\end{argument}

\Example

The following command closes the open files associated with the file
identifiers \co{INFIL} and \co{OUTFIL}:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{closefile infil outfil}
\end{Verbatim}
\end{quote}

The equivalent action is:

\begin{quote}
\begin{verbatim}
(closefile infil outfil)
\end{verbatim}
\end{quote}

\subsection{\co{COMPOUND}}

Creates a new compound value from an arbitrary number of elements. If
no elements are specified, the function returns the empty list.

\co{COMPOUND} is a stateless function and can be used on either the
LHS or RHS.

\Format

\co{COMPOUND} [\it{element}] \ldots

\begin{argument}
\item[element]

  Any valid scalar or compound value expression.
\end{argument}

\ReturnValue

A compound value that contains all the elements of the
specified arguments.

\Example

The following rule pushes a new value onto a stack by creating a new
compound value from the new scalar value plus the current compound
value.

\begin{quote}
\begin{verbatim}
(rule push-stack
    (agenda ^$ID <agenda-object> ^tasks <task-list>)
  -->
    (modify <Agenda-object> ^tasks (compound new-task <task-list>)))
\end{verbatim}
\end{quote}

\begin{note}
  RuleWorks does not support multilevel lists; the value returned
  above is a compound value whose elements are all scalar, not a
  compound value with one scalar element and a nested compound value.
\end{note}

\co{COMPOUND} is the only function you can use in commands to the
RuleWorks interpreter:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{make box ^card-in-slot (compound memory keyboard)}
\end{Verbatim}
\end{quote}

\subsection{\co{CONCAT}}

Concatenates (splices) the print forms of its arguments.

\Format

\co{CONCAT} [\it{value-expr}] \ldots

\begin{argument}
\item[value-expr]

  A RuleWorks expression that evaluates to a value to be
  concatenated. You can specify any number of values.

  If you specify a compound value, RuleWorks treats each element as a
  separate argument.
\end{argument}

\ReturnValue

A single scalar symbolic atom whose print name is the result of
splicing together all of its arguments without inserting any
spaces. If the result is too big to fit in a single atom, the function
truncates it at the maximum symbol size (see
Chapter~\ref{c:workingmem}) and issues a warning.

\Example

The following table shows three calls to the \co{CONCAT} function and
their results:

\begin{tabularx}{\columnwidth}{Xl}
  \toprule
  Function Call & Print Form of Return Value \\
  \midrule
  \verb,(CONCAT a b c), & ABC \\
  \verb,(CONCAT A |b| c), & AbC \\
  \raggedright
  \verb,(bind <x> |Fast |), \verb,(bind <y> |program!|), \verb,  (CONCAT <x> || <y>), &  Fast program! \\
  \bottomrule
\end{tabularx}

\subsection{\co{COPY}}

Makes a new object from an existing object. The existing object
remains unchanged as a result of this operation. If you specify
one or more attributes and values in the \co{COPY}, the new object is
created with the new values you supply. In any case, the new
object has a new \verb|$ID| and a new time-tag. For more information
about objects, see Section 2.2.

Note that the first argument to the \co{COPY} action must be a
variable, while the first argument to the \co{COPY} command must be a
constant.

You can also use \co{COPY} as a function with the \co{BIND} action.

\Format (for action)

\co{COPY} \it{ID-variable} [\{\ct\it{attribute} \it{value-expression}\} \ldots]

\Format (for command)

\co{COPY} \it{instance-id} [\{\ct\it{attribute} \it{value}\} \ldots]

\begin{arguments}
\item[ID-variable]

  A variable bound to a value of type \co{INSTANCE-ID}, indicating the
  object to be duplicated. The object must be visible to the active
  entry block. This argument can be used only in source code.

\item[instance-id]

  A constant of type \co{INSTANCE-ID}, indicating the object to be
  duplicated. The object must be visible to the active entry
  block. This argument can be used only at the command interpreter
  level.

\item[attribute]

  An optional argument, this represents an attribute whose value is to
  be changed during the copy operation. You must specify a value with
  each attribute; you can specify any number of attribute-value pairs.

\item[value-expression]

  Any scalar or compound value (if you specify a compound attribute)
  is a valid argument to the \co{COPY} action, including function
  calls and arithmetic expressions.

\item[value]

  A scalar or compound value (if you specify a compound
  attribute). You cannot use expressions or call functions (except the
  \co{COMPOUND} function) in an argument to the \co{COPY} command.
\end{arguments}

\ReturnValue

The \co{COPY} action returns the \co{INSTANCE-ID} atom that identifies
the new WMO.

\Example

The following example shows a rule from the sample program,
\co{KIWI.OPS}, rewritten to use a \co{COPY} action.

\begin{quote}
\begin{verbatim}
(rule verify-configuration:kiwindows-needs-2-memory-cards-found-one
    (active-context ^name verify-configuration)
    (kiwindows)
    (memory ^$ID <mem-id>)
    -(memory ^$ID <> <mem-id>)
  -->
    (make error ^severity warning ^message |Insufficient memory|)
    (write (crlf) |Caution: KiWindows requires two memory cards,|
           (crlf) | but you have only one memory card.|
           (crlf) | Fixup: adding another memory card to your order.|
           (crlf))
    (copy <mem-id>))
\end{verbatim}
\end{quote}

The following example shows the equivalent \co{COPY} command and its
results:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{ppwm memory}
#31 [CONVERT-SINGLE-ITEM-INPUT-THING-TO-PARTS:MEMORY] (MEMORY)
\RWP\cmd{copy #31}
\RWP\cmd{ppwm memory}
#31 [CONVERT-SINGLE-ITEM-INPUT-THING-TO-PARTS:MEMORY] (MEMORY)
#32 [| main |] (MEMORY)
\end{Verbatim}
\end{quote}

\subsection{\co{CRLF}}

Causes the \co{WRITE} action to move to the next line. Valid inside a
\co{WRITE} action only.

\Format

\co{CRLF}

\Arguments

None.

\Example

The following \co{WRITE} action:

\begin{quote}
\begin{verbatim}
(write (crlf) |Caution: You need to buy the base CPU unit.|
       (crlf) |  Fixup: adding a CPU BOX to your order.|
       (crlf))
\end{verbatim}
\end{quote}

produces the output

\begin{quote}
\begin{verbatim}
Caution: You need to buy the base CPU unit.
  Fixup: adding a CPU BOX to your order.
\end{verbatim}
\end{quote}

\subsection{\co{CS}}

Displays the active contents of the conflict set, that is,
instantiations of rules contained in or activated by the active entry
block.

The command displays instantiations in the following format:
\begin{quote}
  \it{rule-name} \verb|#|\it{instance-id-1} \it{time-tag-1}
  \verb|#|\it{instance-id-2} \it{time-tag-2} \ldots
\end{quote}
where \verb|#|\it{instance-id-1} is the \co{INSTANCE-ID} of an object
that matches the first CE on the left-hand side and \it{time-tag-1} is
its time-tag, \verb|#|\it{instance-id-2} matches the second CE, and so
on.

\Format

\co{CS}

\Example

The following command displays the contents of the conflict set:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{cs}
   POP-ACTIVE-CONTEXT #35 40
   VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS #35 40 #32 37
   VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS #35 40 #29 34
   VERIFY-CONFIGURATION:NEED-DISK #35 40
   VERIFY-CONFIGURATION:NEED-OUTPUT #35 40
   MAKE-CONTEXT-ACTIVE #6 6
   MAKE-CONTEXT-ACTIVE #5 5
   MAKE-CONTEXT-ACTIVE #4 4
   MAKE-CONTEXT-ACTIVE #3 3
\end{Verbatim}
\end{quote}

\subsection{\co{DEBUG}}

Pauses execution after the current rule or \co{ON-} construct and
invokes the RuleWorks command interpreter.

This action is effective only when contained in an entry or rule block
that was compiled with the Debug qualifier set to \co{YES} or
\co{MAYBE} (see Chapter~\ref{c:compiling} for more information on
compiling RuleWorks programs). If the block was compiled with Debug
\co{NO}, the \co{DEBUG} action is a no-op.

When you compile an entry block with Debug set to \co{YES}, the
command interpreter automatically appears when the entry block begins
executing and when it ends. To achieve this effect with Debug set to
\co{MAYBE}, put a \co{DEBUG} action in your \co{ON-ENTRY} and
\co{ON-EXIT} statements. Other good places to put \co{DEBUG} actions
are in error-checking rules (rules that match when your program is not
running correctly) and catchers.

\Format

\co{DEBUG}

\Arguments

None.

\Example

RuleWorks debugging commands are allowed after the \co{DEBUG} action,
and will be executed by the command interpreter. For example:

\begin{quote}
\begin{verbatim}
(on-entry
    (make agenda ^tasks (compound start work stoop))
    (debug)
    (watch rules)
    (make control ^name print-err-messages))
\end{verbatim}
\end{quote}

\subsection{\co{DECLARATION-BLOCK}}

Names a group of object class, method, or external routine
declarations so that they can be shared among multiple entry block or
rule blocks.

Declaration blocks are optional; both object classes and external
routines can be declared inside entry blocks or rule blocks.  However,
if a declaration is inside an entry block or rule block, that
declaration is private and cannot be shared. Instances of objects
declared privately are not visible to any other block.

All object classes that are related by inheritance must be contained
in the same block. A subclass cannot inherit from a parent class
declared in a different block. Similarly, methods must be declared in
the same block as the class to which they are attached.

A declaration block must not contain any executable program statements
(that is, rules, catchers, or \co{ON-} constructs). It must be
entirely contained in a single source file.

The block must be terminated with an \co{END-BLOCK} declaration.

\Format

\co{DECLARATION-BLOCK} \it{block-name}

\begin{argument}
\item[block-name]

  A symbol that names the block. This name must be distinct from all
  other block names in your program.
\end{argument}

\Example

This example shows a block of two \co{OBJECT-CLASS} declarations:
\begin{quote}
\begin{verbatim}
(declaration-block line-items)

(object-class item
    ^item-code
    ^item-name
    ^quantity
    ^price-per
    ^item-total)

(object-class shippable-item
    (inherits-from item)
    ^part-number)

(end-block line-items) ; the block name is optional here,
                       ; but is checked if supplied
\end{verbatim}
\end{quote}
                    
\subsection{\co{DEFAULT}}

Sets the default input source for the \co{ACCEPT-ATOM} and
\co{ACCEPT-LINE-COMPOUND} functions, or the default output destination
for the \co{WRITE} action or trace output. If you do not use the
\co{DEFAULT} command or action to specify otherwise, RuleWorks reads
input from the keyboard and sends output to the screen (see Chapter~\ref{c:workingmem} for platform-specific details.)

\Format

\co{DEFAULT} \it{file-id} \it{io-type}

\begin{arguments}
\item[file-id]

  The source from which input is to be read or the destination to
  which output is to be written. The value can be either a file
  identifier or the symbol \co{NIL}. If you specify a file identifier,
  \co{DEFAULT} sets the source or destination to the open file
  associated with that name. If you specify \co{NIL}, the input is
  read from the keyboard or output is sent to the screen.

  Use the \co{OPENFILE} action or command to open a file for access in
  a specified mode and create a file identifier.

\item[io-type]

  A keyword that specifies whether the default is to be set for input,
  debugging output, or program output. The following table lists the
  keywords you can specify.
\end{arguments}

\begin{tabularx}{\columnwidth}{ccX}
  \toprule   
  I/O Type & Mode  &       Description  \\
  \midrule
  \co{ACCEPT} & \co{IN}  &  Input read by the \co{ACCEPT-ATOM}
                           and \co{ACCEPT-LINE-COMPOUND}
                           functions. \\
  \co{TRACE} & \co{OUT}, \co{APPEND}  & Output generated by the \co{TRACE} debugging command. \\
  \co{WRITE} & \co{OUT}, \co{APPEND} & Output produced by the \co{WRITE} action. \\
  \bottomrule
\end{tabularx}

\Example

The following commands open a file for input, associate it with a file
identifier \co{INFIL}, and set it to be the default source for the
\co{ACCEPT-ATOM} and \co{ACCEPTLINE-COMPOUND} functions:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{openfile infil order.dat in}
\RWP\cmd{default infil accept}
\end{Verbatim}
\end{quote}

The equivalent actions are:

\begin{quote}
\begin{verbatim}
(openfile infil order.dat in)
(default infil accept)
\end{verbatim}
\end{quote}

\subsection{\co{DISABLE}}

Revokes a run-time feature that you had previously set with an
\co{ENABLE} command. To disable a feature, specify the appropriate
keyword.

Default keywords:
\begin{center}
\begin{tabular}{ll}
  \toprule
  Keyword     & Feature \\
  \midrule
  \co{BLOCK-NAMES} & Block names displayed with rule names \\
  \co{WARNING}     & Run-time warning and error messages   \\
  \co{WMHISTORY}   & \co{WMHISTORY} command \\
  \bottomrule
\end{tabular}
\end{center}

\Format

\co{DISABLE} \it{keyword}

\begin{argument}
\item[keyword]

  A keyword that specifies the feature to be disabled. The keywords
  and the features they disable are listed in \co{DISABLE} Keywords
  table.
\end{argument}

\co{DISABLE} keywords:
\begin{center}
\begin{tabular}{ll}
  \toprule
  Keyword & Feature \\
  \midrule
  \co{BACK}        & \co{BACK} command \\
  \co{TIMING}      & \co{PME} package \\
  \co{BLOCK-NAMES} & Block names displayed with rule names \\
  \co{WARNING}     & Run-time warning and error messages \\
  \co{WMHISTORY}   & \co{WMHISTORY} command \\
  \bottomrule
\end{tabular}
\end{center}

\Example

The following command disables the \co{WMHISTORY} command:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{disable wmh}
\end{Verbatim}
\end{quote}


\subsection{\co{EBREAK}}

Controls breakpoints on entry blocks.

When used with no arguments, the command displays a numbered list of
the entry blocks that have breakpoints set. When used with the \co{ON}
and \co{OFF} keywords, respectively, \co{EBREAK} sets and clears
breakpoints for entry blocks. Breakpoints are set or cleared on both
the \co{ON-ENTRY} and \co{ON-EXIT} clauses by a single command.

When the run-time system encounters a breakpoint on an entry block, it
finishes the \co{ON-ENTRY} or \co{ON-EXIT} construct (if-any),
displays a message in the following format, and invokes the command
interpreter:

\begin{quote}
\begin{verbatim}
%RUL-I-BREAKNOTED, Execution paused by break
EBREAK entering entry-block-name
\end{verbatim}
or
\begin{verbatim}
EBREAK exiting entry-block-name
\end{verbatim}
\end{quote}

Note that the block name is always displayed in \co{EBREAK} messages,
whether \co{BLOCK-NAMES} is enabled or disabled.

\Format

\co{EBREAK}

\begin{arguments}
\item[entry-block-name] 

  The name of an entry block. You can specify one or more entry block
  names.

\item[number]

  An integer displayed with the list of entry blocks when you give an
  EBREAK command with no argument. This argument is valid with the
  \tt{OFF} keyword only.

\item[\normalfont{\co{*}}] 

  All entry blocks.
\end{arguments}

\subsection{\co{ENABLE}}

Enables the run-time feature specified by a keyword argument (see
\co{ENABLE} Keywords). The default state for all features is disabled.

Giving an \co{ENABLE} command with no argument results in a display of
the features that are currently enabled. You can revoke a feature with
the \co{DISABLE} command.

\Format

\co{ENABLE} \it{keyword}

\begin{argument}

\item[keyword]

  A keyword that specifies the feature to be enabled.
\end{argument}

\begin{tabularx}{\columnwidth}{lX}
  \toprule
  Keyword     & Feature \\
  \midrule
  \co{BACK} [\it{n}] & \co{BACK} command. The optional argument, \it{n}, is  
                       an integer that specifies the number of    
                       cycles that may be backed over. The default 
                       is 64. \\
  \co{TIMING} &  PME package. \\
  \co{BLOCK-NAMES} & Block names displayed with rule names. \\
  \co{WARNING} & Run-time warning and error messages. \\
  \co{WMHISTORY} & \co{WMHISTORY} command. \\
  \bottomrule
\end{tabularx}

\Example

The following command enables run-time messages.

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{enable war}
\end{Verbatim}
\end{quote}

\subsection{\co{END-BLOCK}}

Closes a block construct. Each \co{DECLARATION-BLOCK},
\co{ENTRY-BLOCK}, and \co{RULE-BLOCK} declaration must end with an
\co{END-BLOCK}. If you want, you can repeat the name of the block in
the \co{END-BLOCK} declaration.

\Format

\co{END-BLOCK} [\it{block-name}]

\begin{argument}

\item[block-name]

  The symbol that names the block being terminated. This argument is
  optional, but if you provide it the compiler checks it.
\end{argument}

\Example

This example shows a simple \co{DECLARATION-BLOCK} with a matching
\co{END-BLOCK}:
\begin{quote}
\begin{verbatim}
(declaration-block line-items)

(object-class item
    ^item-code
    ^item-name
    ^quantity
    ^price-per
    ^item-total)

(object-class shippable-item
    (inherits-from item)
    ^part-number)

(end-block line-items) ; the block name is optional here,
                       ; but is checked if supplied
\end{verbatim}
\end{quote}
                     
\subsection{\co{END-GROUP}}

Closes a rule group. Each \co{RULE-GROUP} declaration must end with an
\co{END-GROUP}. If you want, you can repeat the name of the group in
the \co{END-GROUP} declaration.

\Format

\co{END-GROUP} [\it{group-name}]

\begin{argument}
\item[group-name]

  The symbol that names the group being terminated. This argument is
  optional, but if you provide it the compiler checks it.
\end{argument}

\subsection{\co{ENTRY-BLOCK}}

Defines an entry point that is visible to the system linker and is
callable by RuleWorks and other languages.

At least one \co{ENTRY-BLOCK} declaration is required for each
RuleWorks routine. To make a RuleWorks program that you can run, at
least one entry block must be named \co{MAIN} (or \co{|main|}).

RuleWorks entry blocks can accept arguments and return a value.
You declare arguments with an \co{ACCEPTS} clause and the return value
with a \co{RETURNS} clause.

An entry block can contain object class, and external routine
declarations, and executable RuleWorks statements (that is, \co{ON-}
statements, rules and catchers). It must be entirely contained in a
single source file. However, an entry block can invoke rule blocks and
declaration blocks that are contained in other files.

The entry block must close with an \co{END-BLOCK} declaration.

\Format

\co{ENTRY-BLOCK} \it{block-name}

\qquad[\co{(ACCEPTS} \{\verb|<|\it{f-param-name}\verb|>|
[\verb|[|\it{size}\verb|]|] \it{ext-type} [\it{passing-mech}]\} \ldots\verb|)|]

\qquad[\co{(RETURNS} \{\verb|<|\it{f-param-name}\verb|>|
[\verb|[|\it{size}\verb|]|] \it{ext-type} [\it{passing-mech}]\} \ldots\verb|)|]

\qquad[\co{(ACTIVATES} \it{rule-block-name}\verb|)|]

\qquad[\co{(USES} \it{decl-block-name}\verb|)|]
  
\qquad[\co{(STRATEGY} \co{MEA}\verb,|,\co{LEX}\verb|)|]

\begin{argument}
\item[block-name]

  A symbol that names the block. This name must be distinct from all
  routine names and other block names in your program and must conform
  to any restrictions imposed by your platform's linker. It must also
  satisfy the C language requirements for a function name:

  \qquad cannot contain the characters \verb,"<>[]%^-,,

  \qquad less than 32 characters long,

  \qquad different from all C keywords.
\end{argument}

\begin{note}
  Naming an entry block \co{MAIN} (or \verb,|main|,), with no
  \co{ACCEPTS} or \co{RETURNS} clause, generates a C-compliant ``main
  function.''  RuleWorks automatically adds a return value of type
  \co{LONG}.
\end{note}

The RuleWorks compiler generates a warning if an entry block named
\co{MAIN} violates the C language restrictions on passing parameters
to the main function: either zero or two parameters, one \co{SHORT}
and one array of strings.

\Clauses

\co{ACCEPTS}

Defines the input argument list of the entry block. Note that the name
and data type are required for each argument; the size (of an array)
and passing mechanism are optional.

\it{f-param-name}: A RuleWorks variable name for the formal
parameter.
Variables bound to input arguments are visible
to the entry block's \co{ON-} statements. They are not
visible to rules unless you put them in working
memory in your \co{ON-ENTRY} or \co{ON-EVERY} statement.

\co[[\it{size}]\co]: If a parameter is an array, you can indicate its
expected size with either an integer or a variable bound to a previous
parameter. The size is optional; the brackets are not.

\it{ext-type}: The external data type of input argument is
passed. This argument is optional; the default mechanism is determined
by the argument's external data type (see Table~\ref{t:6-1}).

\it{passing-mech}: The mechanism by which the argument is passed.
This arument is optional; the default mechanism is determined by the
arguments external data type.

\co{RETURNS}

Specifies the external data type and passing mechanism
information for the entry block's return value, if any. This
clause is optional, but if you provide one RuleWorks checks
that you also provide at least one \co{RETURN} action.

\it{f-param-name}: A variable name for the return value. This is optional; you can use a name to make
your code easier to read.

\co[\it{size}\co]: If the return value is compound, you must indicate
its expected size. You can use either an input parameter of an integer
type (byte, short long, and so on; see Table 6-2), or an integer
constant.

\it{ext-type}: The external data type of the return value. See
Table~\ref{t:6-1} for RuleWorks external data types.

\it{passing-mech}: The passing mechanism by which the value is
returned. This argument is optional; the default mechanism is
determined by the value's external data type (see Table~\ref{t:6-1}).

\co{ACTIVATES}

Indicates which rule blocks are eligible to fire. This clause
is optional.

\it{rule-block-name}: A symbol that names a rule block. You specify
one or more rule blocks.

All rule blocks activated by an entry block are enabled automatically
when the entry block is called. They must all use the same
conflict-resolution strategy as the entry block that invoke them.

\co{USES}

Indicates which declaration blocks are shared by the entry
block. This clause is optional.

\it{decl-block-name}: A symbol that names a declaration block.  You
can specify one or more declaration blocks.

The declaration block(s) used by an entry block must be
compiled before the entry block itself can be compiled.

\co{STRATEGY}

Specifies the conflict-resolution strategy (see Section~\ref{s:conflict}).
This clause is optional. If you do not declare a strategy,
the default \co{MEA} is used.

\co{LEX}: The lexicographic-sort strategy.

\co{MEA}: The means-end analysis strategy.

\Example

This example shows a simple counting program:
\begin{quote}
\begin{verbatim}
(entry-block |main|
    (accepts <argc> long
             <argv> [2] asciz)
    (returns long))

(object-class iterator ^count)

(object-class limit ^value)

(on-entry
    (write |argC is| <argc> |argV is| <argv> (crlf))
    (bind <num-arg> (integer (nth <argv> 2)))
    (make limit ^value <num-arg>)
    (make iterator ^count 1))

(on-exit (return 0))

(rule increment-rule
    (limit ^value <lim>)
    (iterator ^$id <it> ^count {<num> < <lim> })
  -->
    (write <num> (crlf))
    (modify <it> ^count (<num> +1)))

(rule now-done
    (limit ^$id <limit-id> ^value <lim>)
    (iterator ^$id <it> ^count <lim>)
  -->
    (write <lim> (crlf))
    (remove <it>)
    (remove <limit-id>)

(end-block |main|)
\end{verbatim}
\end{quote}

This example produces the following output, when compiled with
Debug \co{YES}:
\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
System> count 5
ArgC is 2 argV is $1$dua0:[williams.ruleworks]count.exe;4 5
%RUL-I-EBREAK, EBREAK encountered on |main| &ON-ENTRY
\RWP\cmd{run}
1
2
3
4
5
%RUL-I-EBREAK, EBREAK encountered on |main| &On-EXIT
\RWP\cmd{run}
System>
\end{Verbatim}
\end{quote}


\subsection{\co{EVERY}}

Finds all instances of a specific class, including descendents of that
class.

\Format

\co{EVERY} \it{class-name}

\begin{argument}
\item[class-name]

  A symbolic atom that names an object class visible to the active
  entry block.
\end{argument}

\ReturnValue

A compound value whose elements are the \co{INSTANCE-ID}s of all WMOs
that belong to class-name. If class-name has children, instances of
those children are included in the returned compound.

The \co{INSTANCE-ID}s are returned in no particular order.

If the specified class is not visible, returns the empty list
(\co{(COMPOUND)}).

\Example

The following uses the value returned by the \co{EVERY} function
in a \co{FOR-EACH} action:
\begin{quote}
\begin{verbatim}
(bind <dogs> (every dog))
(for-each <dog> in <dogs>
    (wash-pet <dog>)
    (pet-to-vet <dog>)
    (pet-gets-treat <dog>))
\end{verbatim}
\end{quote}

(\co{wash-pet}, \co{pet-to-vet}, and \co{pet-gets-treat} are
hypothetical external routines. Their definitions are left as an
exercise for the reader.)

\subsection{\co{EXIT}}

An obsolescent synonym for the \co{QUIT} command.

\Format

\co{EXIT}

\Example

The following command exits from the command interpreter and returns
control to the operating system:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{exit}
System>
\end{Verbatim}
\end{quote}

\subsection{\co{EXTERNAL-ROUTINE}}

Declares a function or subroutine written in a language other than
RuleWorks. Defines the data types and passing mechanisms of the
arguments needed to call the external routine. (See
Section~\ref{s:calling} for information on data types and passing
mechanisms.)

Other RuleWorks entry blocks must also be declared as external
routines. However, an entry block can call itself recursively with no
external routine declaration.

\Format

\co{EXTERNAL-ROUTINE} \it{routine-name}

\qquad[\co{(ALIAS} \it{actual-routine-name}\co{)}]

\qquad[\co{(ACCEPTS} \{[\verb|<|\it{f-param-name}\verb|>|
[\verb|[|[\it{size}]\verb|]|]] \it{ext-type} [\it{passing-mech}]
\} \ldots\verb|)|]

\qquad[\co{(RETURNS} \{[\verb|<|\it{f-param-name}\verb|>|
[\verb|[|\it{size}\verb|]|] \it{ext-type} [\it{passing-mech}]
\} \ldots\verb|)|]

\begin{argument}
\item[routine-name]

  The name of the external routine. This must be a symbol that is
  different from all other routine names and all block names in the
  program. It must also be different from all RuleWorks actions,
  built-in functions, and relational operators (\co{AND}, \co{NOT},
  and \co{OR}). These restrictions are enforced by the RuleWorks
  compiler.

  The routine name must also satisfy the C language requirements for a
  function name:

  \qquad cannot contain the characters \verb|"<>[]%^-|,

  \qquad less than 32 characters long,

  \qquad different from all C keywords.
\end{argument}

\Clauses

\co{ALIAS}

Declares that the external routine's name is not the actual name
against which it is to be linked. The most common use of this clause
is to map a case-sensitive routine name to a RuleWorks symbol.

\it{actual-routine-name}: The real name of the external routine.

\co{ACCEPTS}

Specifies the name, data type and passing mechanism of the arguments
to be passed out to the external routine. The \co{ACCEPTS} clause is
optional. If you declare any arguments you must also declare the data
type of each argument; the name and passing mechanism are
optional. Arguments for the \co{ACCEPTS} clause are as follows:

\it{f-param-name}: A formal parameter name for an argument to be
passed out, for documentation purposes.

\co[[\it{size}]\co] If included, this declares the argument to be an
array. The size of the array is optional; the brackets are not. The
size may be an integer or a variable previously bound to an integer in
this \co{ACCEPTS} clause.

\it{ext-type}: The name of the external data type. Valid external
types are: \co{BYTE}, \co{SHORT}, \co{LONG}, \co{UNSIGNED-BYTE},
\co{UNSIGNED-SHORT}, \co{UNSIGNED-LONG}, \co{SINGLE-FLOAT},
\co{DOUBLE-FLOAT}, \co{ASCIZ}, \co{ASCID}, and \co{ATOM}.

\it{passing-mech}: Valid passing mechanisms are: \co{BY REFERENCE
  READ-ONLY}, \co{BY REFERENCE READ-WRITE}, and \co{BY VALUE}.

\co{RETURNS}

Also an optional clause, this describes the external routine's return
value. Arguments for the \co{RETURNS} clause are as follows:

\it{f-param-name}: A formal parameter name for the return value,
for documentation purposes.

\co[\it{size}\co]: If the return value is an array, you must declare
its size. You can use a constant or a variable.

\it{ext-type}: The name of the external data type. Valid external
types are: \co{BYTE}, \co{SHORT}, \co{LONG}, \co{UNSIGNED-BYTE},
\co{UNSIGNED-SHORT}, \co{UNSIGNED-LONG}, \co{SINGLE-FLOAT},
\co{DOUBLE-FLOAT}, \co{ASCIZ}, \co{ASCID}, and \co{ATOM}.

\it{passing-mech}: Valid passing mechanisms are \co{BY REFERENCE} and
\co{BY VALUE}.

\Example

The following example declares a VMS routine that returns a
random number:
\begin{quote}
\begin{verbatim}
(external-routine mth$random
    (accepts <seed> long by reference)
    (returns long by value))
\end{verbatim}
\end{quote}

The next example maps the case-sensitive name \co{XtParent} to the
RuleWorks symbol \verb|XT_PARENT|:

\begin{quote}
\begin{verbatim}
(external-routine xt_parent
    (accepts <param1> integer)
    (returns <param2> integer)
    (alias "XtParent"))
\end{verbatim}
\end{quote} 

The following example declares the ULTRIX routine that
returns an environment variable:

\begin{quote}
\begin{verbatim}
(external-routine getenv__; from the POSIX library
    (accepts <env-name> asciz by reference read-only)
    (returns <env-value> asciz by reference))
\end{verbatim}
\end{quote}

\subsection{\co{FOR-EACH}}

Allows iteration over each element in a compound
\verb|<CONDITION> (TIN)| or table value. The index variable is bound
and the specified RHS actions are executed once for each iteration.

\Format (for a compound)

\co{FOR-EACH} \verb|<|\it{element}\verb|>| \co{IN} \it{compound-value}
\it{RHS-action} \ldots

\begin{arguments}
\item[\co{<}element\co{>}]

  The index variable that is bound to each element of the compound
  value.

\item[compound-value]

  The compound value to be acted upon. This argument may be a bound
  compound variable or an expression that returns a compound value.

\item[RHS-action]

  Any valid RHS action. You can specify any number of actions.

\item[\co{<}data-value\co{>}]

  The index variable that is bound to each data value in the table
  value.

\item[\co{<}key-name\co{>}]

  The index variable that is bound to each key value in the table
  value.

\item[table-value]

  The table value to be acted upon. This argument may be a bound table
  variable or an expression that returns a table value.
\end{arguments}

\Example

The following examples uses the \co{FOR-EACH} action to print out the
names of all the cards in a Kiwi-9200 computer card cage.  Note that
this also shows how to bind an index variable.

\begin{quote}
\begin{verbatim}
(rule print-out-cage:do-it
    (active-context ^name print-out-cage)
    (box ^cards-in-slot <cards> )
  -->
    (write (crlf) |The card cage will contain: |)
    (bind <slot-counter> 1)
    (for-each <card> in <cards>
        (write (crlf) (tabto 20) |Slot number| <slot-counter>
            |contains a| <card>)
        (bind <slot-counter> ( <slot-counter> + 1 ))))
\end{verbatim}
\end{quote}

\subsection{\co{FLOAT}}

Converts a numeric value into a floating-point number. \co{FLOAT} is a
stateless function and can be used on either the LHS or RHS.

\Format

\co{FLOAT} \it{numeric-expr}

\begin{argument}
\item[numeric-expr]

  An expression that evaluates to an \co{INTEGER} or \co{FLOAT}. If
  supplied with a \co{SYMBOL}, the \co{FLOAT} function converts the
  first white space delimited token, if possible. If not, or if the
  argument is an \co{OPAQUE} or \co{INSTANCE-ID}, the function issues
  a warning message and returns the floating-point number zero.
\end{argument}

\begin{center}
  \begin{tabular}{lll}
    \toprule
    Function Call & Return Value &  Warning Message? \\
    \midrule
    \verb,(FLOAT 3), & 3.0  & No \\
    \verb,(FLOAT 3.2), &  3.2 & No \\
    \verb,(FLOAT |3.2|), &  3.2 & No \\
    \verb,(FLOAT |76 trombones|), & 76.0 &  No \\
    \verb,(FLOAT 2+2), & 0.0 & Yes \\
    \verb,(FLOAT #32), &  0.0 &  Yes \\
    \bottomrule
  \end{tabular}
\end{center}

\subsection{\co{GENATOM}}

Returns a system-generated atom, with an optional prefix.

The RuleWorks atom generator is used by the \co{GENATOM} and
\co{GENINT} actions, and by the \verb|rul_genint|, \verb|rul_gensym|,
and \verb|rul_gensymp| routines. Every atom generated for any of these
routines is unique while the program is running. The atom generator is
global, so that all entry blocks called in a program have unique
generated atoms.

The generated atoms consist of an integer and an optional
prefix. Within a program run, the first use of the atom generator
returns 1, the second 2, and so on. The \verb|rul_genint| routine and
the \co{GENINT} action return an integer with no prefix. The
\verb|rul_gensymp| routine and the \co{GENATOM} action return an
integer with a prefix that you can specify, or use the default prefix
\co{G:}. The \verb|rul_gensym| routine returns an integer prefixed by
\co{G:}. The table below shows several uses of the atom generator and
the atoms it returns:

\begin{center}
  \begin{tabular}{lll}
    \toprule
    Routine Call or RHS Action & Atom Generated \\
    \midrule
    \verb|rul_genint| &  \verb|1| \\
    \verb|rul_gensymp(R:)| & \verb|R:2| \\
    \verb|(GENATOM)| & \verb|G:3| \\
    \verb|(GENINT)| & \verb|4| \\
    \verb|rul_gensym| & \verb|G:5| \\
    \bottomrule
  \end{tabular}
\end{center}

The atom generator is reset by the \co{RESTORESTATE} action and
command.

\Format

\co{GENATOM} [\it{prefix}]

\begin{argument}
\item[prefix]

  A RuleWorks expression, the print form of which will be the first
  part of the return value. The default prefix is \co{G:}.
\end{argument}

\ReturnValue

A symbol that consists of the prefix you specify (if any) with an
integer appended to it.

\Example

The following \co{BIND} action binds the variable \co{<TRANSACTION-ID>}
to the atom produced by the \co{GENATOM} function:

\begin{quote}
\begin{verbatim}
(bind <transaction-id> (genatom trans-))
\end{verbatim}
\end{quote}

\subsection{\co{GENINT}}

Returns a system-generated \co{INTEGER}. See \co{GENATOM} for details
on the RuleWorks atom generator.

\Format

\co{GENINT}

\ReturnValue

An \co{INTEGER} value.

\Example

The following \co{BIND} action binds the variable \co{<TRANSACTION-ID>}
to the atom produced by the \co{GENINT} function:

\begin{quote}
\begin{verbatim}
(bind <transaction-id> (genint))
\end{verbatim}
\end{quote}

\subsection{\co{GET}}

Given a variable bound to an object identifier and an attribute name,
returns the value of that attribute of that object. The variable can
be bound on either the LHS or the RHS, but \co{GET} is allowed on the
RHS only.

The \co{GET} function lets you access attribute values on the RHS that
you did not bind to variables on the LHS. You can bind the identifier
of the object on the LHS, and then use the \co{GET} function to return
the value of any attribute in that object.  You do not need to bind
each attribute value separately, only the \co{INSTANCE-ID}.

\Format

\co{GET} \it{object-id} \ct\it{attribute-name}

\begin{arguments}
\item[object-id]

  A variable bound to, or an expression that evaluates to, an
  \co{INSTANCE-ID} value. Variables can be bound on either the LHS or
  the RHS of the rule. The class of the object must be visible to the
  active entry block.

  The RuleWorks compiler issues a warning if it is unable to verify
  that this argument is an \co{INSTANCE-ID}.

\item[\ct{attribute-name}]

  A symbolic expression that names an attribute in the specified
  object. It is a run-time warning to use an attribute that is not
  declared for the specified class.
\end{arguments}

\ReturnValue

The value of the specified attribute in the specified instance; or
\co{NIL} if the arguments are not correct.

\Example

The following example shows one use of the \co{GET} function:

\begin{quote}
\begin{verbatim}
(object-class fruit
    ^fruit-name
    ^color)

(rule make-a-similar-one
    (fruit ^$ID <The-fruit> ^fruit-name apple)
  -->
    (make fruit
        ^fruit-name apple 
        ^color (get <The-fruit> ^color)))
\end{verbatim}
\end{quote}

\subsection{\co{IF}\ldots\co{THEN}\ldots\co{ELSE}\ldots}

Executes one or more RHS actions when a relational expression is true,
or executes one or more different RHS actions when the expression is
false. In other words, provides a branch in the flow of control.

\Format

\co{IF} \co(\it{rel-expr}\co)
     \co{THEN} \it{RHS-action}
     [\co{ELSE} \it{RHS-action}]

\begin{arguments}
\item[rel-expr]

  A relational expression that determines which RHS actions are to be
  executed. This argument must evaluate to either true or false. It
  may not contain any SQL functions.
  \begin{note}
    RuleWorks does not have Boolean values. Therefore, this argument
    must be a comparison of two expressions. It must not be a single
    value. For example, RuleWorks does not allow
    \verb|IF (TRUE) THEN)|.
  \end{note}

\item[RHS-action]

  Any RuleWorks action. You can specify any number of actions.
\end{arguments}

\Clauses

\co{THEN}

Specifies the actions that are to be executed when the
relational expression is true. This clause is required.

\co{ELSE}

Specifies the actions that are to be executed when the
relational expression is false. This clause is optional.

\subsection{\co{INTEGER}}

Converts a numeric atom into an integer. \co{INTEGER} is a stateless
function and can be used on either the LHS or RHS.

\Format

\co{INTEGER} \it{numeric-expr}

\begin{argument}
\item[numeric-expr]

  An expression that evaluates to an \co{INTEGER} or \co{FLOAT}. If
  supplied with a \co{SYMBOL}, the \co{INTEGER} function converts the
  first white space delimited token, if possible. If not, or if the
  argument is an \co{OPAQUE} or \co{INSTANCE-ID}, the function issues
  a warning message and returns the integer zero.
\end{argument}

\ReturnValue

The nearest integer (by rounding) that corresponds to the
specified value.

\Example

The following table shows several calls to the \co{INTEGER}
function and their results:

\begin{center}
  \begin{tabular}{lll}
    \toprule
    Function Call & Return Value &  Warning Message? \\
    \midrule
    \verb|(INTEGER 3)| &  3 & No \\
    \verb|(INTEGER 3.5)| &  4  & No \\
    \verb|(INTEGER 3.5e4)| &  35000 & No \\
    \verb,(INTEGER |3.2|), &  3 & No \\
    \verb,(INTEGER |110 cornets|), & 110 & No \\
    \verb|(INTEGER 2+2)| &  0 & Yes \\
    \verb|(INTEGER #12)| &  0 & Yes \\
    \bottomrule
  \end{tabular}
\end{center}

\subsection{\co{IS-OPEN}}

Tests whether a file has already been opened. \co{IS-OPEN} is valid on
the RHS only.

\Format

\co{IS-OPEN} \it{file-id}

\begin{argument}
\item[file-id]

  A symbolic atom that was associated with a filespec in an
  \co{OPENFILE} action. (See Section 4.5 for more information on input
  and output.)
\end{argument}

\ReturnValue

The mode (\co{IN} or \co{OUT}) if the file is open; \co{NIL} if it is
not.  If the file is open in mode \co{APPEND}, the function returns
\co{OUT}.  (See the \co{OPENFILE} action for more information on I/O
mode.)

\Example

The following \co{IF}\ldots\co{THEN}\ldots\co{ELSE}\ldots{} action
uses the \co{IS-OPEN} function:

\begin{quote}
\begin{verbatim}
(if ((is-open infil) <> nil)
 then
    (closefile infil))
\end{verbatim}
\end{quote}

\subsection{\co{LENGTH}}

Returns the number of elements in a compound value. \co{LENGTH} is a
stateless function and can be used on either the LHS or RHS.

\Format

\co{LENGTH} \it{compound-val}

\begin{argument}
\item[compound-val]

  The compound value to be counted. This argument can be a bound
  compound variable or a function that returns a compound value.
\end{argument}

\ReturnValue

An integer that specifies the number of elements in the
compound value.

\Example

The following condition element shows the \co{LENGTH} function used on
the LHS:

\begin{quote}
\begin{verbatim}
(box ^card-in-slot <cards> ^max-cards <= (length <cards>))
\end{verbatim}
\end{quote}

The following action shows the \co{LENGTH} function used on the RHS:

\begin{quote}
\begin{verbatim}
(write |The card cage contains| (length <cards> ) |cards.|)
\end{verbatim}
\end{quote}

\subsection{\co{MAKE}}

Creates a working-memory object of the specified class, with the
specified attribute values (if any). RuleWorks uses the default values
for attributes you do not specify (see Chapter~\ref{c:workingmem}).

\begin{note}
  When you create WMOs at the command interpreter prompt, the first
  argument to the \co{MAKE} command must be a constant. In contrast,
  when you create WMOs in source code, the first argument to the
  \co{MAKE} action can be a variable or a call to the \co{GET}
  function.
\end{note}

You can also use \co{MAKE} as a function with the \co{BIND} action.

\Format (for action)

\co{MAKE} \it{class-name} [\{\ct\it{attribute} \it{value-expression}\} \ldots]

\Format (for command)

\co{MAKE} \it{class-name} [\{\ct\it{attribute} \it{value}\} \ldots]

\begin{arguments}
\item[class-name]

  A symbol or variable that names the class of the object to be
  created; it must be visible to the active entry block.

\item[\ct{attribute}]

  A symbol that names an attribute declared in the specified
  class. This argument is optional, but if you specify any attributes,
  you must specify a value with each attribute.

\item[value-expression]

  Any scalar or compound expression (if you specify a compound
  attribute) is a valid argument to the \co{MAKE} action, including
  function calls and arithmetic expressions.

\item[value]

  A scalar or compound value (if you specify a compound
  attribute). You cannot use expressions or call functions (except the
  \co{COMPOUND} function) in an argument to the \co{MAKE} command.
\end{arguments}

\ReturnValue

The \co{MAKE} action returns the \co{INSTANCE-ID} atom that identifies
the new WMO.

\Example

The following rule uses the \co{MAKE} action to create an object of
class \co{ACTIVE-CONTEXT}, with a bound variable as the value of the
\verb|^NAME| attribute.

\begin{quote}
\begin{verbatim}
(rule make-context-active
    (context ^name <context-name> ^$ID <context-id>)
  -->
    (make active-context ^name <context-name>)
    (remove <context-id>))
\end{verbatim}
\end{quote}

The following \co{MAKE} command creates an object of class \co{BOX}
with one element each in the compound attributes \verb|^CARD-IN-SLOT|
and \verb|^CARD-IN-SLOT-OBJ-ID|:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{(make box ^card-in-slot (compound memory)}
             \cmd{(^card-in-slot-obj-id (compound #32)))}
\end{Verbatim}
\end{quote}

The \co{MAKE} command below uses the bracket notation to index a
compound attribute:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{make box ^card-in-slot[3] keyboard}
                    \cmd{^card-in-slot-obj-id[3] #49}
\end{Verbatim}
\end{quote}

\subsection{\co{MATCHES}}

Displays the \co{INSTANCE-ID}s of the objects that match CEs in
the specified rule(s). The command lists the objects that
match the first CE, then the second CE, then the first two
CEs, and so on. The class name of each CE is shown as part of
its heading. The output is in the following format:

\verb|>>>RULE_NAME<<<|

\verb|***matches for| \co(\it{class-name-1}\co)\verb|***|

\co\#\it{instance-id}

\vdots

\verb|***matches for| \co(\it{class-name-2}\co)\verb|***|

\co\#\it{instance-id}

\vdots

\verb|***matches for 1 2 ***|

\co\#\it{instance-id} \co\textasciitilde\it{instance-id}

\vdots

\verb|***complete instantiations***|

\co\#\it{instance-id} \it{time-tag} \co\#\it{instance-id} \it{time-tag}

For more information about displaying match information, see
Chapter~\ref{c:debugging}.

\Format

\co{MATCHES} \it{rule-name} \ldots

\begin{arguments}
\item[rule-name]

  The name of a rule for which match information is to be
  displayed. You can specify the name of one or more rules.
\end{arguments}

\Example

The following command displays match information of a rule that is not
eligible for the conflict set.

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{matches foo}
>>> foo <<<
to be specified
\end{Verbatim}
\end{quote}

\begin{note}
  There is no instantiation displayed after the last heading. The next
  command displays the matches of a rule that is eligible for the
  conflict set:
\end{note}

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{matches bar}
>>> bar <<<
to be specified
\end{Verbatim}
\end{quote}

(The third CE in this rule is negative, so no matches for 3, with a
match for 1 and 2, means the rule can fire.)

\subsection{\co{MAX}}

Given one or more arguments, returns the largest. The
elements of compound values are added to the argument list as
if they were separate scalar values.

\Format

\co{MAX} \it{value} \ldots

\begin{arguments}

\item[value]

  Any RuleWorks expression. The first value determines the valid data
  type; using mixed types causes a warning message.  You may specify
  any number of value, either compound or scalar.
\end{arguments}

\ReturnValue

The greatest of the arguments.

\Example

The following table shows several calls to the \co{MAX} function and
their results:

\begin{center}
\begin{tabular}{lll}
  \toprule
  Function Call & Return Value & Warning Message? \\
  \midrule
  \co{(max 3 2.0 1)} & 3 & No \\
  \co{(max 3.2 10)} &   10 & No  \\
  \co{(max -3.2 -10)} &   -3.2 &   No \\
  \co{(max boy (compound man woman) girl)} & \co{woman} & No \\
  \co{(max 3.2 cat 10)} & 10 & Yes \\
  \bottomrule
\end{tabular}
\end{center}

\begin{note}
  Ruleworks issues a warning when it finds a value of an invalid data
  type, but it does process the rest of the arguments list. (See
  Appendix E for the collating sequences for symbols.)
\end{note}

\subsection{\co{MIN}}

Given one or more arguments, returns the smallest. The elements of
compound values are added to the argument list as if they were
separate scalar values.

\Format

\co{MIN} \it{value} \ldots

\begin{arguments}
\item[value]

  Any RuleWorks expression. The first value determines the valid data
  type; using mixed types causes a warning message.  You may specify
  any numbert of values, either compound or scalar.
\end{arguments}

\ReturnValue

The smallest of the arguments.

\Example

The following table shows several calls to the \co{MIN} function and their
results:

\begin{center}
\begin{tabular}{lll}
  \toprule
  Function Call & Return Value & Warning Message? \\
  \midrule
  \co{(min 3 2.0 1)} & 1 & No \\
  \co{(min 3.2 10)} &  3.2 & No  \\
  \co{(min -3.2 -10)} &   -10 &   No \\
  \co{(min boy (compound man woman) girl)} & \co{boy} & No \\
  \co{(min 3.2 cat 10)} & 3.2 & Yes \\
  \bottomrule
\end{tabular}
\end{center}

\begin{note}
  RuleWorks issues a warning when it find a value of an invalid data
  type, but it does process the rest of the arguments list.
\end{note}

\subsection{\co{MODIFY}}

Changes one or more values in an existing working-memory object. The
object must be visible to the active entry block.  The object's
time-tag is updated but its \co{INSTANCE-ID} remains the same.

\begin{note}
  When you change WMOs at the command interpreter prompt, the first
  argument to the \co{MODIFY} command must be a constant.  In
  contrast, when you change WMOs in a rule, the first argument to the
  \co{MODIFY} action can be a variable or a call to the \co{GET}
  function.
\end{note}

You can also use \co{MODIFY} as a function with the \co{BIND} action.

\Format (for action)

\co{MODIFY} \it{ID-variable} \{\ct\it{attribute} \it{value-expression}\} \ldots

\Format (for command)

\co{MODIFY} \it{instance-id} \{\ct\it{attribute} \it{value}\} \ldots

\begin{arguments}
\item[ID-variable]

  An expression of type \co{INSTANCE-ID}, indicating the object to be
  modified. This argument can be used in rules only.

\item[instance-id]

  A constant of type \co{INSTANCE-ID}, indicating the object to be
  modified. This argument can be used only at the command interpreter
  level.

\item[attribute]

  An attribute name that specifies which value in the object is to be
  changed. You must specify a value with each attribute.

\item[value-expression]

  Any scalar or compound value (if you specify a compound attribute)
  is a valid argument to the \co{MODIFY} action, including function
  calls and arithmetic expressions.

\item[value]

  A scalar atom or a compound value containing constants (if you
  specify a compound attribute). You cannot use expressions or call
  functions (except \co{COMPOUND}) in an argument to any command.
\end{arguments}

\ReturnValue

The \co{MODIFY} action returns the \co{INSTANCE-ID} atom that
identifies the changed WMO.

\Example

The following action changes on attribute of a \co{SOFTWARE-OPTION}
object:

\begin{quote}
\begin{verbatim}
(modify <the-software> ^media-type FD-35)
\end{verbatim}
\end{quote}

The equivalent command is shown below:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wm #29}
#29 [EXPAND-PART-SKELETONS:KIWICALC] (KIWICALC ^NAME KIWICALC
^PART-NUMBER S-CA-9200 ^PRINTNAME KiwiCalc Spreadsheet Software ^PRICE
29.95 ^IS-EXPANDED YES
\RWP\cmd{modify #29 ^media-type fd-35}
\RWP\cmd{wm #29}
#29 [ | | ] (KIWICALC ^MEDIA-TYPE FD-35 ^NAME KIWICALC
^PART-NUMBER S-CA
-9200 ^PRINTNAME KiwiCalc Spreadsheet Software ^PRICE 29.95
^IS-EXPANDED YES)
\end{Verbatim}
\end{quote}

See Chapter 4.4 for examples of modifying compound attributes.

\subsection{\co{NOT}}

Performs a logical negation on its operand, that is, returns true when
the operand is false and false when the operand is true.

\begin{note}
  This is a relational operator, not a match predicate. \co{NOT} may
  be used only in relational expressions within
  \co{IF}\ldots\co{THEN}\ldots\co{ELSE}\ldots{} or
  \co{WHILE}\ldots\co{DO}\ldots{} actions.
\end{note}

\Format

\co{NOT} \it{relation}

\begin{operands}
\item[relation]

  The relational expression to be negated. This must evaluate to
  either true or false.
\end{operands}

\Example

The following code fragment shows the \co{NOT} operator in an
\co{IF}\ldots\co{THEN}\ldots\co{ELSE}\ldots{} action:
\begin{quote}
\begin{verbatim}
(if (not (<day> = work-day))
 then (sleep-late)
 else (go-to-work))
\end{verbatim}
\end{quote}

\subsection{\co{NTH}}

Accesses the value at the specified index into a compound
value. \co{NTH} is a stateless function and can be used on either the
LHS or RHS.

\Format

\co{NTH} \it{compound-value} \it{index}

\begin{arguments}
\item[compound-value]

  The compound value that is to be searched. This argument may be
  bound compound variable or a function that returns a compound value.

\item[index]

  An integer expression (anything that evaluates to an integer) that
  specifies the location of the desired value. The index of the first
  element is 1, not 0.
\end{arguments}

\ReturnValue

The element value at the specified location in a compound
value. If the location does not exist, the function returns
\co{NIL}.

\Example

The following action prints the first element of a bound compound
variable:

\begin{quote}
\begin{verbatim}
(write (crlf) |Slot 1 contains | (nth <cards> 1))
\end{verbatim}
\end{quote}

\subsection{\co{NEXT}}

Displays the instantiation that the run-time system will select from
the conflict set for the act phase of the next recognize-act
cycle. The \co{NEXT} command displays the instantiation in the same
format as the \co{CS} command, with the addition of the rule-firing
counts:

\it{n} (\it{m}): \it{rule-name} \verb|#|\it{instance-id-1}
\it{time-tag-1} \verb|#|\it{instance-id-2} \it{time-tag-2} \ldots

where \it{n} is the global count and \it{m} is the local (to the block
invocation) count.

\Format

\co{NEXT}

\Arguments

None.

\Example

The following command shows that the next instantiation the run-time
system will select from the conflict set is the rule
\co{MODIFY-SOFTWARE-MEDIA:35-CHEAPEST} acting on objects \verb|#38|,
\verb|#32|, and \verb|#45|:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{next}
MODIFY-SOFTWARE-MEDIA:35-CHEAPEST #38 71 #32 58 #45 70
\end{Verbatim}
\end{quote}

\subsection{\co{OBJECT-CLASS}}

Declares an object class and the attributes associated with it. All
\co{OBJECT-CLASS} declarations must appear before any executable
program elements. \co{OBJECT-CLASS} declarations can be contained in
entry blocks, declaration blocks, or rule blocks.

\Format

\co{OBJECT-CLASS} \it{class-name}

\qquad[\verb|(INHERITS-FROM| \it{parent-class}\verb|)|]

\qquad{\ct\it{attribute-name} [\it{data-type}]

\qquad\qquad[\co{(DEFAULT} \it{value}\co)]

\qquad{\ct\it{attribute-name} \co{COMPOUND} [\it{data-type}]

\qquad\qquad[\co{(DEFAULT} \it{value}\co)]

\qquad\qquad[\co{(FIL} \it{value}\co)]

\begin{note}
  This format shows one scalar and one compound attribute, for clarity
  only. RuleWorks does not require that you declare all scalar
  attributes first, nor that you have at least one scalar
  attribute. You can declare compound and scalar attributes in any
  order.
\end{note}

\begin{arguments}

\item[class-name]

  The only required argument, this represents the name of the new
  object class. It must be a symbol that is different from all other
  classes in the block, and must not be a RuleWorks predicate.

  If the \co{OBJECT-CLASS} declaration is contained in an entry block,
  and the entry block uses declaration blocks, the class name must
  also be different from all the classes in the used blocks.

  A class name in an entry block may be the same as a class in a rule
  block, even if the entry block activates the rule block.

\item[attribute-name]

  Specifies the name of an attribute for the new object class.

\item[data-type]

  Specifies the data type of an attribute. This argument is optional,
  but if you do specify a data type RuleWorks enforces that domain
  restriction. The valid data types and their system-defined default
  values are shown in the RuleWorks Data Types table.

\begin{center}
\begin{tabular}{lll}
  \toprule
  Name & Default Value \\
  \midrule
  \co{INTEGER} & \co{0} \\
  \co{FLOAT}  & \co{0.0}\\
  \co{NUMBER}  & \co{0} \\
  \co{SYMBOL}  & \co{NIL} \\
  \co{OPAQUE} & \verb|%x0| \\
  \co{INSTANCE-ID} & \verb|#0| \\
  \co{INSTANCE-ID OF} & \verb|#0| \\
  \co{ANY}  & \co{NIL} \\
  \bottomrule
\end{tabular}
\end{center}

An attribute typed \co{NUMBER} can be assigned either an \co{INTEGER}
or a \co{FLOAT} value. \co{ANY} is the default when no data type is
declared. \co{INSTANCE-ID} optionally restricts the value to a
named object class when this Format is used:

\co{INSTANCE-ID OF} \it{class-name}
\end{arguments}

\Clauses

\co{INHERITS-FROM}

Specifies a parent object class from which the class being
declared is to acquire attribute names and characteristics.
If present, this clause must precede any attribute names.

\it{parent-class}: The name of the parent object class. The parent
class must be previously declared in the same block. A subclass cannot
inherit from a parent class declared in a different block.

See Table 2-1 in Section 2.1 for a table on restrictions on
declaring attributes in a subclass of a parent class.

\co{DEFAULT}

Establishes the initial value for an attribute when an object of this
object class is created. The default value is ignored if another value
is specified in the \co{MAKE} action.

\it{value}: The default value must be the same attribute shape as the
attribute. That is, scalar attributes must have a scalar default
value; compound attributes must have a compound default value. Use the
\co{COMPOUND} function to create the default value for a compound
attribute.

\co{COMPOUND}

Declares the attribute to be compound rather than scalar. See
Chapter~\ref{c:workingmem} for details.

\co{FILL}

Defines an initial value for certain elements of a compound
value. This filler value is used only when the length of the compound
value is increased dynamically but no value is specified for those
elements.

\it{value}: The scalar value to be used as a filler. See Chapter 2.3.5
for more information.

\Example

The following example declares class \co{BOX} that inherits from
class \co{PART} and has two additional compound attributes.

\begin{quote}
\begin{verbatim}
(object-class box
    (inherits-from part)
    ^card-in-slot compound
    ^card-in-slot-obj-id compound))
\end{verbatim}
\end{quote}

\subsection{\co{ON-EMPTY}}

Defines a set of RHS actions that are executed by RuleWorks
when it reaches the selection phase of the recognize-act
cycle and the conflict set is empty. After the \co{ON-EMPTY}
actions are executed, the \co{ON-EXIT} actions fire.

An \co{ON-EMPTY} statement must be contained in an \co{ENTRY-BLOCK}.
You can use and change the input arguments of the entry block
in the \co{ON-EMPTY} actions.

\Format

\co{ON-EMPTY} \it{action} \ldots

\begin{arguments}
\item[action]

  Any RuleWorks RHS action. You can specify one or more actions.
\end{arguments}

\subsection{\co{ON-ENTRY}}

Defines a set of RHS actions that are executed immediately
after an entry block is calle and before any rules fire.
After the \co{ON-ENTRY} actions are executed, the RuleWorks
run-time proceeds to the match phase of the first
recognize-act cycle.

An \co{ON-ENTRY} statement must be contained in an \co{ENTRY-BLOCK}.
You can use and change the input arguments of the entry block
in the \co{ON-ENTRY} actions.

\Format

\co{ON-ENTRY} \it{action} \ldots

\begin{arguments}
\item[action]

  Any RuleWorks RHS action. You can specify one or more actions.
\end{arguments}

\subsection{\co{ON-EVERY}}

Defines a set of RHS actions that are executed by RuleWorks after the
act phase of one recognize-act cycle and before the match phase of the
next cycle.

If the last rule fired executes a \co{RETURN} or \co{QUIT} action, the
\co{ON-EVERY} actions are not executed. When the conflict set is
empty, the \co{ON-EMPTY} actions are executed but the \co{ON-EVERY}
actions are not.

An \co{ON-EVERY} statement must be contained in an \co{ENTRY-BLOCK}.
You can use and change the input arguments of the entry block in the
\co{ON-EVERY} actions.

\Format

\co{ON-EVERY} \it{action} \ldots

\begin{arguments}
\item[action]

  Any RuleWorks RHS action. You can specify one or more actions.
\end{arguments}

\subsection{\co{ON-EXIT}}

Defines a set of RHS actions that are executed by RuleWorks
just before control returns to the caller of the entry block.

The \co{ON-EXIT} actions are executed when the reason for control
being returned is that the conflict set is empty or that a
\co{RETURN} action was executed. The \co{ON-EXIT} actions are not
executed after a \co{QUIT} action is executed. (See Figure 5-1 for
an illustration.)

An \co{ON-EXIT} statement must be contained in an \co{ENTRY-BLOCK}. You
can use and change the input arguments of the entry block in
the \co{ON-EXIT} actions.

\Format

\co{ON-EXIT} \it{action} \ldots

\begin{arguments}
\item[action]

  Any RuleWorks RHS action. You can specify one or more actions.
\end{arguments}

\subsection{\co{OPENFILE}}

Opens a file for access in a specified mode, and associates it with a
file identifier.

\Format

\co{OPENFILE} \it{file-id} \it{filespec} \it{mode}

\begin{arguments}
\item[file-id]

  A symbol that represents the file identifier with which the
  specified file is to be associated.

\item[filespec]

  The file specification for the file to be opened. If you are opening
  a file for input, the file must already exist.

\item[mode]

  A keyword that indicates whether the specified file is to be opened
  for input or output. The following table, \co{OPENFILE} Keywords,
  lists the keywords you can specify.
\end{arguments}

TODO

Mode  Effect

OPENFILE KeywordsIN  The action opens an existing file for
reading only.

OUT  The action creates a new file and opens it for writing
only.

APPEND  The action opens an existing file for writing and
sets the file pointer to the end of the file.

\Example

The following action opens the file \co{ORDER.DAT} for input and
associates it with the file identifier \co{INFIL}:
\begin{quote}
\begin{verbatim}
(openfile infil order.dat in)
\end{verbatim}
\end{quote}
The equivalent command is:
\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{openfile infil order.dat in}
\end{Verbatim}
\end{quote}

\subsection{\co{OR}}

Performs a logical inclusive disjunction on its two operands,
that is, returns true when either one or both of its operands
is true.

Note: This is a relational operator, not a match predicate.  \co{OR}
may be used only in relational expressions within
\co{IF}\ldots\co{THEN}\ldots\co{ELSE}\ldots{} or
\co{WHILE}\ldots\co{DO}\ldots{} actions.

\Format

\it{relation} \co{OR} \it{relation}

\begin{operands}
\item[relation]

  The relational expressions to be combined. These operands must
  evaluate to either true or false.
\end{operands}

\Example

The following code fragment shows the \co{OR} operator in an
\co{IF}\ldots\co{THEN}\ldots\co{ELSE}\ldots{} action:
\begin{quote}
\begin{verbatim}
(if ((<weather> = sunny) or (<weather> = warm))
 then (do_outdoor_chores)
 else (do_indoor_chores))
\end{verbatim}
\end{quote}

\subsection{\co{P} (Production)}

Synonym for \co{RULE}, the production statement is provided for
compatibility with DEC OPS5 Version 4.0A and other OPS
systems. See \co{RULE} for details.

\Format

\co{P} \it{production-name} 

\qquad(\it{condition-element}) \dots

\qquad\co{-->}

\qquad(\it{action}) \ldots

\subsection{\co{POSITION}}

Scans the specified compound variables for the specified scalar
value. \co{POSITION} is a stateless function and can be used on either
the LHS or RHS.

By default, \co{POSITION} test for identity; you can specify a
different predicate. The function always stops at the first occurrence
of the predicate evaluating to true.

\Format

\co{POSITION} \it{compound-var} [\it{predicate}] \it{scalar-value}

\begin{arguments}
\item[compound-var]

  A compound variable bound to the compound value that is to be
  scanned.

\item[predicate]

  A predicate that specifies the comparison between elements of the
  compound value and the scalar value. This argument is optional; if
  you do not specify a predicate, RuleWorks uses the default identity
  predicate.

  You can use any scalar predicate except containment and
  non-containment.

\item[scalar-value]

  A scalar constant or a bound variable.
\end{arguments}

\ReturnValue

The integer index of the first element in compound-var that
satifies the comparison specified by the predicate with the
scalar-value; or zero if no element of compound-var satisfies
the comparison.

\Example

Given the following object:
\begin{quote}
\begin{verbatim}
#28 69 (BOX ^CARD-IN-SLOT (COMPOUND MEMORY MEMORY MEMORY
KEYBOARD FD-35) ^CARD-IN-SLOT-OBJ-ID (COMPOUND #31 #39 #37
#45) ^NAME BOX ^PART-NUMBER KI-9200 ^PRINTNAME Kiwi-9200 CPU
Base Unit ^PRICE 999.95 ^IS-EXPANDED YES)
\end{verbatim}
\end{quote}
And assuming \verb|<CARDS>| is bound to \verb|^CARD-IN-SLOT|, the following
function call returns the value 1:
\begin{quote}
\begin{verbatim}
(position <cards> memory)
\end{verbatim}
\end{quote}

The following attribute-value tests use the containment and
similarity predicates in conjunction with the \co{POSITION}
function to test two consequtive elements of a compound
value:
\begin{quote}
\begin{verbatim}
^list {[+] ~= color <list>}
^list [(position <list> ~=color) + 1] <> blue
\end{verbatim}
\end{quote}


\subsection{\co{PPCLASS}}

Displays the parents and attributes of the specified object class. The
attributes are listed under the name of the object class that declared
them, with their shape, domain restriction, and default and fill
values (if any).

Alternatively, displays the hierarchy of classes defined in the active
block.

\Format

\co{PPCLASS} [\it{object-class}]

\begin{argument}
\item[object-class]

  The name of an object class that is visible to the active entry
  block.

  This argument is optional. If you supply no argument, \co{PPCLASS}
  displays the class structure of the active block.
\end{argument}

\Example

The following example shows the \co{PPCLASS} output for the class
\co{BOX} from the sample program, \co{KIWI}.

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\textcolor{blue}{RuleWorks>} \textcolor{red}{ppclass box}

PART
^PART-NUMBER
^NAME symbol
^PRICE float
^IS-EXPANDED symbol (default NO)

BOX
^CARD-IN-SLOT compound symbol
^CARD-IN-SLOT-OBJ-ID compound instance-id
\end{Verbatim}
\end{quote}

\subsection{\co{PPWM}}
TODO

Displays all objects, or all instances of a specified class, or only
those instances that match a specified object pattern. Object patterns
are similar to CEs and can include attributes specified with values,
tests, disjunctions, and conjunctions. Object patterns cannot include
variables or function calls.

The \co{PPWM} command displays the following information about an
object:
\begin{itemize}
\item Its \co{INSTANCE-ID}.

\item The name of the construct that last modified the object (for
  example, a rule or \co{ON-} clause). If you last modified the object at
  the interpreter prompt, the construct name is the symbol \co{RUL}.

\item Its class name, its attributes, and the attributes' values.
\end{itemize}

Scalar attributes whose value is \co{NIL}, and compound attributes
whose value is \co{(COMPOUND)} are not displayed unless you have
declared a \co{DEFAULT} value for the attribute.

The system displays this information in the following format:

\begin{center}
  \verb|#|\it{INSTANCE-ID} \verb|[|\it{rule-name}\verb|]|
  \verb|(|\it{class-name} \it{attribute-1} \it{value-1}
  \it{attribute-2} \it{value-2} \ldots\verb|)|
\end{center}

If you do not specify a pattern, the command displays all the visible
WMOs.

\Format

\co{PPWM} [\it{class-name}] \ct\it{attribute} \it{value}

Predicate value

<<value.>>

{test.}

\begin{arguments}
\item[class-name]

  A symbol that names an object class that is visible to the active
  entry block. If you specify a class that has inherited subclasses,
  objects of those subclasses are also displayed.

\item[attribute]

  An attribute that describes a characteristic of the objects to be
  displayed and contains the corresponding value. If you specify any
  attributes, you must also specify at least one value for each
  attribute.

  If you specify a compound attribute, you can index it with a left
  bracket, an integer constant, and a right bracket
  (\verb|[|index\verb|]|).

\item[predicate]

  Any of the valid match predicate.

\item[value]

  This argument must be a scalar atom. Compound values, created with
  the \co{COMPOUND} function, are not allowed.

\item[test]

  A value, a predicate followed by a value, or a disjunction of
  values:
\end{arguments}

\Example

The following commands illustrate the syntax for compound
attributes:
\begin{quote}
\begin{verbatim}
RuleWorks>ppwm box ^card-in-slot [3] keyboard

#28 [CHOOSE-SLOTS:PLACE-NONMEMORY] (BOX ^CARD-IN-SLOT
(COMPOUND MEMORY MEMORY KEYBOARD ^CARD-IN-SLOT-OBJ-ID
(COMPOUND #31 #39 #37 ^PART-NUMBER ki-9200 ^NAME Kiwi-9200
CPU Base Unit ^PRICE 999.95 ^IS-EXPANDED YES)

RuleWorks>ppwm box ^card-in-slot [+] memory

~28 {CHOOSE-SLOTS:PLACE-NONMEMORY] (BOX ^CARD-IN-SLOT
(COMPOUND MEMORY MEMORY KEYBOARD) ^CARD-IN-SLOT-OBJ-ID
(COMPOUND #31 #39 #37) ^part-NUMBER KI-9200 ^NAME Kiwi-9200
CPU Base Unit ^PRICE 999.95 ^IS-EXPANDED YES)
\end{verbatim}
\end{quote}

\subsection{\co{QUIT}}

Terminates execution of the current image and returns control to the
operating system. If there are other actions in the rule, they are not
executed. The \co{ON-EXIT} actions are not executed after a \co{QUIT}
action. You can return a value with \co{QUIT}. Valid arguments for
\co{QUIT} include \verb|$FAILURE| and \verb|$SUCCESS|, as well as any
integer. RuleWorks substitutes either 0 or 1, as appropriate for the
operating system, for \verb|$FAILURE| and \verb|$SUCCESS|.

Entering \co{QUIT} at the command interpreter is equivalent to
pressing Ctrl/Z on VMS systems, Ctrl/D on UNIX systems.

\Format (for action)

\co{QUIT} [\it{value-expr}]

\Format (for command)

\co{QUIT} [\it{return-value}]

\begin{arguments}
\item[value-expr]

  The value returned by RuleWorks. This argument is optional; it can
  be an expression that evaluates to a scalar value,
  \verb|$FAILURE|, or \verb|$SUCCESS|. This argument can be used in
  rules only.

\item[return-value]

  The value returned by RuleWorks. This argument is optional; it can
  be a constant, \verb|$FAILURE|, or \verb|$SUCCESS|. You cannot use
  expressions or function calls (except to \co{COMPOUND}) as arguments
  to any command.
\end{arguments}

\Example

The following command exits from the command interpreter and
returns control to the operating system:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{QUIT}
$
\end{Verbatim}
\end{quote}

The following example uses the \co{QUIT} action to terminate
execution with a return value indicating success.
\begin{quote}
\begin{verbatim}
(rule success
    (context ^$ID <context> ^task complete)
  -->
    (remove <context>)
    (quit $success))
\end{verbatim}
\end{quote}

When this rule fires, the \co{QUIT} action causes the run-time system
to stop executing recognize-act cycles immediately.  The compiler
provides a warning when any actions follow \co{RETURN} or \co{QUIT}
actions.

The entry block's \co{ON-EVERY} and \co{ON-EXIT} statements are not
executed after a \co{QUIT} action.

\subsection{\co{RBREAK}}
TODO

Controls breakpoints on rules and rule groups.

When used with no arguments, the command displays a numbered list of
the rules and groups that have breakpoints set. When used with the
\co{ON} and \co{OFF} keywords, respectively, \co{RBREAK} sets and
clears breakpoints for rules and groups. Breakpoints for rule groups
are set or cleared for all rules in the group by a single command.

When the run-time system encounters a breakpoint on a rule, it
finishes the current recognize-act cycle, displays a message in the
following format, and invokes the command interpreter:

%RUL-I-RBREAK, RBREAK encountered on rule[group] name
%RUL-I-BREAKNOTED, Execution paused by break.

\Format

ON
{
rule-name
rule-group-name
}...
OFF
{
rule-name
rule-group-name
number
}

The keywords and arguments are optional. If you do not
specify the name of a rule, the command displays the names of
the rules and groups for which breakpoints are set.

\Arguments

rule-name

A symbol that names a rule. You can specify one or more.

rule-group-name

A symbol that names a rule group. You can specify one or
more.

*

All rules and groups that have breaks set.

\Example

The following command displays the names of the rules of
which breakpoints are set:

RuleWorks> rbreak

1 VERIFY-CONFIGURATION:MOUSE-PORT

2 POP-ACTIVE-CONTEXT

The next commands delete one breakpoint and sets another:

RuleWorks> rbreak off 2

RuleWorks> rbreak on choose-slots:place-nonmemory

The following command redisplays the names of the rules for
which breakpoints are set:

RuleWorks> rbreak

1 VERIFY-CONFIGURATION:MOUSE-PORT

2 CHOOSE-SLOTS:PLACE-NONMEMORY

The following dialog shows what happens when the breakpoint
is reached:
\begin{quote}
\begin{verbatim}
RuleWorks> run

%RUL-I-RBREAK, RBREAK encountered on rule
CHOOSE-SLOTS:PLACE-NONMEMORY

%RUL-I-BREAKNOTED, Execution paused by break



RuleWorks> next

CHOOSE-SLOTS:PLACE-NONMEMORY #47 62 #28 65 #37 56
\end{verbatim}
\end{quote}

\subsection{\co{REMOVE}}
TODO

Deletes one or more objects from working memory. The object must be
visible to the active entry block. Once an object has been removed, it
can no longer be accessed. However, variables bound to the values of
attributes of that object can still be used.

\begin{note}
  When you delete WMOs at the command interpreter prompt, the first
  argument to the \co{REMOVE} command must be a constant.  In contrast,
  when you delete WMOs in a rule, the first argument to the \co{REMOVE}
  action can be a variable or a call to the \co{GET} function.
\end{note}

\Format (for action)

\co{REMOVE} \it{ID-expr} \ldots

\Format (for command)

\co{REMOVE} \{\it{instance-id} \ldots \verb|*|\}

\begin{arguments}

\item[ID-expr]

  A RuleWorks expression that evaluates to a value of type
  \co{INSTANCE-ID}, indicating the object to be deleted. You can
  specify one or more IDs. This argument can be used in rules only.

\item[instance-id]

  A constant of type \co{INSTANCE-ID}, indicating the object to be
  deleted. This argument can be used only at the command interpreter
  level.

\item[\normalfont\co{*}]

  You can specify an asterisk (\co*) to delete all visible
  objects. Objects whose class declarations are neither contained in
  nor used by the active entry block remain in working memory.
\end{arguments}

\Example

The following command deletes all visible objects:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{remove *}
\end{Verbatim}
\end{quote}

The following command deletes the objects whose identifiers
are \verb|#3| and \verb|#4|:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{remove #3 #4}
\end{Verbatim}
\end{quote}

Consider the following rule:

\begin{quote}
\begin{verbatim}
(rule make-context-active
    (context ^name <context-name> ^$ID <context-id>)
  -->
    (make active-context ^name <context-name>)
    (remove <context-id>))
\end{verbatim}
\end{quote}

The \co{REMOVE} action deletes the object bound to the variable
\verb|<CONTEXT-ID>|.

\subsection{\co{REMOVE-EVERY}}

Deletes all the working memory objects that are instances of the
specified class or its subclasses. The class must be visible to the
active entry block. Once an object has been removed, it can no longer
be accessed. However, variables bound to values of attributes of that
object can still be used.

\Format

\co{REMOVE-EVERY} \it{class-name} \ldots

\begin{arguments}
\item[class-name]

  An expression that evaluates to a symbol names an object class. The
  declaration of this class must be contained in or used by the active
  entry block.

  You can also use the symbol
  \verb|$ROOT| to remove all visible objects.
\end{arguments}

\Example

The following example removes working-memory objects when the conflict
set is empty:

\begin{quote}
\begin{verbatim}
(on-empty
    (write |Sorry... Program error. No satisfied rules.| (crlf))
    (remove-every control-context)
    (remove-every local)
    (remove-every input-thing)
    (remove-every error)
    (remove-every part)
    (remove-every input-count)
    (remove-every total-cost)
    (quit 0))
\end{verbatim}
\end{quote}

\subsection{\co{RESTORESTATE}}

Clears and then restores working memory, the conflict set, the \co{GENATOM}
counter, and the \co{INSTANCE-ID} generator to the state recorded in a file
produced by the \co{SAVESTATE} action or command.

The working memory objects contained in the \co{SAVESTATE} file must be
visible to the active entry block. A run-time warning is generated if
the files contains any objects whose class declarations are neither
private to nor shared by the active entry block.

\co{RESTORESTATE} clears all working memory objects before loading the
new state; therefore, variable bindings are lost.

After a \co{RESTORESTATE} action, the \co{GENATOM} and \co{GENINT} functions
produce atoms that are different from any that were recorded
in the saved file. They may repeat atoms that were generated
before the \co{RESTORESTATE} action was executed.

\Format

\co{RESTORESTATE} \it{filespec}

\begin{arguments}
\item[filespec]

  The file specification for a file previously produced by the
  \co{SAVESTATE} action or command. The action uses the contents of
  the file to restore the state of working memory and the conflict
  set. See Chapter~\ref{c:portability} for restrictions on file names.
\end{arguments}

\Example

The following action clears and then restores the contents of working
memory and the conflict set to the same state recorded in the file
\co{CONFIG.DAT}.

\begin{quote}
\begin{verbatim}
(restorestate config.dat)
\end{verbatim}
\end{quote}

\subsection{\co{RETURN}}

Stops the firing of rules in the current entry block, executes the
\co{ON-EXIT} actions (if any), and passes control back to the caller
of the entry block. The \co{RETURN} action is executed immediately, so
any actions that follow it are not executed and a warning is
generated.

This action has one optional argument, the value to be returned. Your
\co{RETURN} action(s) should match the \co{RETURNS} clause of your
\co{ENTRY-BLOCK} declaration. For example, if your entry block has no
\co{RETURNS} clause, a \co{RETURN} action with an argument generates a
compiler warning. Similarly, if your entry block declares a symbolic
return value, a \co{RETURN} action with a numeric argument generates a
run-time warning.

\co{RETURN} actions are valid in entry blocks but not in rule blocks.

Executing more than one \co{RETURN} action generates a warning. If
a value is being returned from the entry block, the value of
the last \co{RETURN} action executed is used.

When you execute a \co{RETURN} command at the RuleWorks interpreter
prompt, and the return is to a RuleWorks entry block, no action of the
caller is executed before the prompt reappears. This allows you to see
working memory in exactly the state the callee left it.

\Format (for action)

\co{RETURN} [\it{value-expr}]

\Format

(for command)

\co{RETURN} [\it{value}]

\begin{arguments}
\item[value-expr]

  The value returned by the entry block. This argument is optional; it
  can be any expression that evaluates to the structure (scalar or
  compound) and domain (integer, symbol, and so on) specified in the
  \co{ENTRY-BLOCK} declaration.

\item[value]

  The value returned by the entry block. This argument is optional; it
  may be a constant or a call to the \co{COMPOUND} function. You cannot use
  any other functions or expressions at the command line.
\end{arguments}

\Example

The following example shows a simple rule that returns a
value:

\begin{quote}
\begin{verbatim}
(rule when-done-return-number-filled
    (task ^name last-step)
    -(order ^status unfilled)
    (totals ^filled-orders <count>)
  -->
    (return <count>))
\end{verbatim}
\end{quote}

\subsection{\co{RJUST}}

Causes the \co{WRITE} action to right-justify output in a field of a
specified width. This function is useful for writing a column of
numbers with decimal positions aligned.

Note: The \co{RJUST} function is valid only inside the \co{WRITE}
action. Calls to the \co{RJUST} function can follow calls to the
\co{CRLF} and \co{TABTO} functions but must directly precede the value
being written.

\Format

\co{RJUST} \it{width}

\begin{argument}
\item[width]

  An integer expression (anything that evaluates to an integer) that
  indicates the width of the field in which output is to be placed. If
  the output being written requires more character positions than you
  specify for the field, the \co{WRITE} action behaves as if the
  \co{RJUST} function had not been specified. That is, the action
  inserts one space and then writes the output.
\end{argument}

\Example

The following \co{WRITE} action writes a vertical list of numbers
right-justified in a column 10 characters wide:

\begin{quote}
\begin{verbatim}
(write (crlf) (rjust 10) |10.06|
       (crlf) (rjust 10) |2.45|
       (crlf) (rjust 10) |56.00|
       (crlf) (rjust 10) |250.00|)
\end{verbatim}
\end{quote}

The output is:

\begin{quote}
\begin{verbatim}
     10.06
      2.45
     56.00
    250.00
\end{verbatim}
\end{quote}  

\subsection{\co{RULE}}

Executes right-hand-side actions when left-hand-side
conditions are met and the rule has been selected from the
conflict set.

\Format

\co(\co{rule} \it{rule-name}

\qquad\co(condition-element\co) \ldots

\quad\co{-->}

\qquad\co(action\co) \ldots\co)

\begin{arguments}
\item[rule-name]

  A unique symbol that names the rule being created. The symbol cannot
  be the name of another rule, a rule-group, a method, or a catcher
  that already exists in the entry block.

\item[condition-element]

  A specified pattern against which working memory objects can be
  matched. Condition elements can be negative, can contain
  conjunctions and disjunctions, and can bind variables that are used
  in other condition elements and in actions on the right-hand side.

  You can specify one or more condition elements. You cannot put a
  negative CE first. See Chapter~\ref{c:conditionelements} for
  information on CEs.

\item[action]

  Any RHS action. You can specify one or more actions. See
  Chapter~\ref{c:actions} for information on actions.
\end{arguments}

\Example

The following rule, named \co{CLOSE-INPUT-FILE:DO-IT}, contains three
CEs and three actions. The second CE binds a
\verb|$ID| variable, \verb|<MY-INPUT-THING>|, which is deleted by the
\co{REMOVE} action. The third CE binds an attribute variable,
\verb|<C>|, which is used in the \co{WRITE} action.

\begin{quote}
\begin{verbatim}
(rule close-input-file:do-it
    (active-context ^name close-input-file)
    (input-thing ^item end-of-file ^$ID <my-input-thing> )
    (input-count ^count <c>)
  -->
    (closefile infil)
    (remove <my-input-thing>)
    (write (crlf) |Read| (<c> - 1) |items from input.| (crlf)))
\end{verbatim}
\end{quote}

\subsection{\co{RULE-BLOCK}}
TODO

Names a collection of rules so that they can be shared among multiple
entry blocks. Rule blocks may contain rules, catchers, and
declarations, but no \co{RETURN} actions and no \co{ON-} constructs.

A rule block must be activated by a RuleWorks entry block.  Rule
blocks can use declaration blocks but they cannot activate other rule
blocks.

The rules in a rule block cannot match objects of classes declared
inside the entry block; they can match only objects of classes
declared inside the rule block or in a declaration block used by the
rule block. Likewise, rules in the entry block cannot match objects of
classes declared inside the rule block.

Each rule block can have its own \co{STRATEGY} clause. However, all rule
blocks activated by an entry block must have the same strategy as that
entry block. It is a run-time warning to activate rule blocks that
have different strategies.

The block must be closed with an \co{END-BLOCK} declaration.

\Format

\co{(RULE-BLOCK} \it{block-name}\co)

[\co{(USES} \it{decl-block-name}\co)]

[\co{(STRATEGY} \co{)}]

\begin{argument}
\item[block-name]

A symbol that names the block. This name must be distinct
from all other block names in your program and must also be a
valid C function name:

cannot contain the characters \verb|"<>[]%^-|,

less than 32 characters long,

different from all C keywords.
\end{argument}

\Clauses

\co{USES}

Indicates which declaration blocks are shared by the entry block. This
clause is optional.

\it{decl-block-name}: A symbol that names a declaration block.  You
can specify one or more declaration blocks.

\co{STRATEGY}

Specifies the conflict-resolution strategy (see
Chapter~\ref{c:intro}).  This clause is optional. If you do not
declare a strategy, the default \co{MEA} is used.

\co{LEX}: The lexicographic-sort strategy.

\co{MEA}: The means-ends analysis strategy.

\subsection{\co{RULE-GROUP}}

Names a collection of rules inside a single entry block or rule
block. If you put each \co{MEA} group in a separate rule group, you
can then enable \co{TRACE} for rule groups and see output for the
\co{MEA} groups without seeing each individual rule.

Rule groups may contain rules and catchers, but no declarations, no
methods, and no \co{ON-} constructs.

The rules in a rule group can match objects of classes declared in the
containing block and objects of classes declared in a declaration
block that is used by the containing block.

The group must be terminated with an \co{END-GROUP} declaration.

\Format

\co{RULE-GROUP} \it{group-name}

\begin{argument}
\item[group-name]

  A symbol that names the group. This name must be distinct from the
  names of all other groups, rules, and catchers in the containing
  block.
\end{argument}

\subsection{\co{RUN}}

Causes the run-time system to execute recognize-act cycles.  You can
optionally specify the number of recognize-act cycles the system
executes.

RuleWorks entry blocks start running by default. Use the \co{DEBUG}
action or the Debug compiler switch to pause execution and invoke the
RuleWorks command interpreter.

\Format

\co{RUN} [\it{integer}]

\begin{argument}
\item[integer]

  The number of global recognize-act cycles the run-time system is to
  execute. This argument is optional. If you do not specify an
  integer, the run-time system executes recognize-act cycles until no
  rules are satisfied or until a \co{RETURN} or \co{QUIT} action, or a
  breakpoint interrupts execution.
\end{argument}

\begin{note}
  If a breakpoint interrupts program execution, the run-time
  system does not execute the number of recognize-act cycles indicated
  by the integer.
\end{note}

\Example

The following command starts executing recognize-act cycles:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{run}
\end{Verbatim}
\end{quote}

The following command executes four recognize-act cycles:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{run 4}
\end{Verbatim}
\end{quote}

\subsection{\co{SAVESTATE}}

Copies to a file the state of working memory, the conflict set, the
\co{GENATOM} and \co{GENINT} counter, and the \co{INSTANCE-ID}
generator. You can later use the \co{ADDSTATE} or \co{RESTORESTATE}
action or command to add to or overwrite the current memory with the
contents of the file.

Only objects that are visible to the active entry block are saved.

\Format

\co{SAVESTATE} \it{filespec}

\begin{argument}
\item[filespec]

  The file specification for the file to which the state of working
  memory and the conflict set is to be copied.
\end{argument}

\Example

The following action copies the state of working memory and
the conflict set to the file \co{CONFIG.DAT}.

\begin{quote}
\begin{verbatim}
(savestate config.dat)
\end{verbatim}
\end{quote}

The equivalent command is:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{savestate config.dat}
\end{Verbatim}
\end{quote}

\subsection{\co{SHOW SPACE}}

Displays information about working memory and the RuleWorks
symbol table. The information consists of the current number
of objects and symbol-table entries, the amount of memory
that these currently occupy, and the largest value that these
have reached during this execution of the program.

\Format

\co{SHOW SPACE}

\Arguments

None.

\Example

The following example shows the \co{SHOW SPACE} command:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{show space}
WORKING-MEMORY OBJECTS SYMBOL TABLE ENTRIES
Current number - 10 Current number - 97
Current space used - 0.6 Kbytes Current space used - 4.4 Kbytes
Maximum number - 12 Maximum number - 97
Maximum space used - 0.7 Kbytes Maximum space used - 4.4 Kbytes
\end{Verbatim}
\end{quote}

\subsection{\co{SHOW VERSION}}

Displays the current version of the RuleWorks compiler (and
the copyright notice).

\Format

\co{SHOW VERSION}

\Arguments

None.

\Example

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{show version}
RuleWorks ä - Version 2.0 EFT1 (11-18-94)
Copyright ã 1994-1995 Digital Equipment Corporation. All
Rights Reserved.
\end{Verbatim}
\end{quote}

\subsection{\co{SPECIALIZE}}

Converts an instance of a parent class to an instance of a descendent
class. The converted object's \co{INSTANCE-ID} does not change as a
result of this action. You can also set or change any attributes
belonging to the descendent class.

\begin{note}
  When you convert WMOs at the command interpreter prompt, the first
  argument to the \co{SPECIALIZE} command must be a constant. In
  contrast, when you convert WMOs in a rule, the first argument to the
  \co{SPECIALIZE} action can be a variable or a call to the \co{GET}
  function.
\end{note}

\Format (for action)

\co{SPECIALIZE} \it{ID-variable} \it{new-class-name-expr}
[\{\it{attribute-name-expr} \it{value-expr}\} \ldots]

\Format (for command)

\co{SPECIALIZE} \it{instance-id} \it{new-class-name}
[\{\it{attribute-name} \it{value}\} \ldots]

\begin{arguments}
\item[ID-variable]

  An expression of type INSTANCE-ID, indicating the object to be
  specialized. This argument can be used in rules only.

\item[new-class-name-expr]

  An expression that evaluates to a symbol that names an object class
  that inherits from the current class of the object being
  specialized.

\item[attribute-name-expr]

  A symbol or bound variable that evaluates to an attribute declared
  in or inherited by the new class. This argument is optional; if you
  do specify an attribute, you must also specify a value for it.

  You can specify any number of attribute-value pairs.

\item[value-expr]

  Any valid RuleWorks expression that evaluates to the same structure
  as the attribute.

\item[instance-id]

  A constant of type \co{INSTANCE-ID}, indicating the object to be
  specialized. The object must be visible to be active entry
  block. This argument can be used only at the command interpreter
  level.

\item[new-class-name]

  A symbol that names an object class that inherits from the current
  class of the object being specialized.

\item[attribute-name]

  A symbol that names an attribute declared in or inherited by the new
  class. This argument is optional; if you do specify an attribute,
  you must also specify a value for it.

  You can specify any number of attribute-value pairs.

\item[value]

  A value that has the same structure as the attribute.
\end{arguments}

\ReturnValue

The \co{SPECIALIZE} action returns the \co{INSTANCE-ID} atom that
identifies the converted object.

\Example

The following rule shows one possible use of the \co{SPECIALIZE}
action:

\begin{quote}
\begin{verbatim}
(rule animal-now-identified-as-a-zebra
    ; if current class is the generic class animal
    (animal ^$ID <my-animal> ^$object-class animal ^name <n>)
    (identification ^name <n> ^is-a zebra)
  -->
    (specialize <My-animal> zebra; new class is zebra
        ^inter-breeds-with (compound horse donkey)))
\end{verbatim}
\end{quote}

\subsection{\co{SQL-ATTACH}}

Specifies the database of interest by executing a \co{DECLARE SCHEMA}
statement. You can specify the source of the schema either by
providing the database filespec itself or by providing a pathname to
the CDD schema definition.

\begin{note}
  The actual attachment to the database usually does not occur until
  the first executable SQL statement after this action is processed.
\end{note}

\Format

\co{SQL-ATTACH} \it{database-spec} [\it{DBKEY-scope}]

\begin{arguments}
\item[database-spec]

  This argument must be either \co{FILENAME} \it{db-filespec} or
  \co{PATHNAME} \it{db-pathname}. The keyword \co{FILENAME} may be
  omitted; the keyword \co{PATHNAME} is required.

  A logical name may be used for all or part of the database filespec
  or for the CDD pathname.

\item[DBKEY-scope]

  A keyword that specifies the duration of validity of database key
  values, either \co{TRANSACTION} or \co{ATTACH}. \co{ATTACH} scoping
  means that a database key value is valid for the entire time your
  program is attached to a given database, rather than just for the
  duration of a single transaction. \co{TRANSACTION} scoping is the
  default.
\end{arguments}

\Example

The following example uses the \co{FILENAME} method. \verb|MY_DB| is a
logical name pointing to the complete filespec for the
database.

\begin{quote}
\begin{verbatim}
(sql-attach filename my_db)
\end{verbatim}
\end{quote}

The next example shows the same attachment except that the scope or
duration of \co{DBKEY} validity is the total time your program is attached
to the database, rather than the duration of the transaction as in the
previous example (by default).

\begin{quote}
\begin{verbatim}
(sql-attach filename my_db attach)
\end{verbatim}
\end{quote}

\subsection{\co{SQL-COMMIT}}

Completes the current SQL transaction and makes permanent any changes
made to the database during the transaction. This action executes a
\co{COMMIT} statement.

\Format

\co{SQL-COMMIT}

\Arguments

None.

\subsection{\co{SQL-DELETE}}

Deletes all or selected records from a specified database table, by
executing a \co{DELETE FROM} statement. This action does not remove
any RuleWorks objects; it is up to you to use \co{REMOVE} actions to
do that.

The \co{SQL-DELETE} action can be executed only within the context
of a \co{READ WRITE} transaction, which you must explicitly start
with an \co{SQL-START} action.

\Format

\co{SQL-DELETE} \it{table-name} [\it{WHERE-clause}]

\begin{arguments}

\item[table-name]

  Specifies the database table from which rows are to be deleted.

\item[WHERE-clause]

  Optionally specifies which records are to be deleted within the
  target table. If the \it{WHERE-clause} is omitted, the default is to
  delete all records in the table specified in the first argument.
\end{arguments}

\Example

The first example deletes all records in table W1:

\begin{quote}
\begin{verbatim}
(sql-delete w1)
\end{verbatim}
\end{quote}

The next example deletes only those records in table W1 that
satisfy the WHERE clause:

\begin{quote}
\begin{verbatim}
(sql-delete w1 |WHERE fld1 = 10 AND fld2 = 'some text'|)
\end{verbatim}
\end{quote}

The records deleted are those with field \verb|fld1| equal to the
value 10, and field \verb|fld2| equal to the string 'some text'. All
other records in W1 are unaffected.

\subsection{\co{SQL-DETACH}}

Detaches your program from any database previously attached by an
\co{SQL-ATTACH} action. This action executes a \co{FINISH} statement and a
COMMIT statement on the current transaction, if any.

\Format

\co{SQL-DETACH}

\Arguments

None.

\subsection{\co{SQL-FETCH-EACH}}
TODO

For each selected database record, binds field value(s) to specified
RuleWorks variable(s) and then performs one or more RHS actions. This
action executes a \co{SELECT} statement.

You can create or change instances of any \co{OBJECT-CLASS} in the RHS
actions performed by the \co{SQL-FETCH-EACH} action. The
\co{OBJECT-CLASS} does not have to match the database table name, nor
do the attribute names have to match the database field names.

\Format

\co{SQL-FETCH-EACH} \verb|<|\it{var}\verb|>| \ldots \verb|(|\co{select-expr}\verb|)| \verb|(|\it{RHS-action}\verb|)| \ldots

<var>

One or more RuleWorks variables to which database field
values are to be bound. These variables must not be bound
prior to the SQL-FETCH-EACH action. They can be used only in
the RHS actions provided as the third argument.

select-expr

An SQL select expression that limits the fetch to specific
database table(s) and record(s) and specifies which database
fields are to be fetched. This expression can include
variables bound prior to the SQ~FETCH-EACH action (either on
the LHS or RHS), but cannot include variables specified in
the first argument.

RHS-action

One or more RuleWorks RHS actions to be performed for each
database record fetched. Note that these actions may not
include any other SQL interface actions.

These actions can use both variables bound prior to the
SQL-FETCH-EACH action and variables specified in the first
argument. If these actions bind any variables, those bindings
are maintained after the SQL-FETCH-EACH action is executed.

\Example

The first example fetches records from database table \verb|tbl_1|,
and binds the values of fields fld1 and fld2 to the RuleWorks
variables <v1> and <v2>. These variables are then used in two
MAKE actions, creating new instances of classes W1 and W2.
The actions are repeated for each database record that
satisfies the FROM and WHERE clauses of the select
expression.

\begin{quote}
\begin{verbatim}
(sql-fetch-each <v1> <v2> (SELECT fld1, fld2 FROM tbl_1 WHERE fld3 = 1)
    (make w1 ^a1 <v2> ^a2 tbl_1)
    (make w2 ^a3 <v1> ^a4 (<v1> + <v2>)))
\end{verbatim}
\end{quote}

The previous example uses symbols in the select expression.
The following example uses RuleWorks variables that are
(presumably) bound earlier in the rule that contains this
SQL-FETCH-EACH action. The optional vertical bars ( | )
around the constant parts of the select expression allow the
compiler to generate more efficient code.
\begin{quote}
\begin{verbatim}
(sql-fetch <v1> <v2> (|SELECT * FROM| <table-name> |WHERE fld3= |<val>)
    (make w1 ^a1 <v2> ^a2 tbl_1)
    (make w2 ^a3 <v1> ^a4 (<v1> + <v2>)))
\end{verbatim}
\end{quote}

In this example, all the fields in the database are selected,
because of the wildcard (*). However, only the first two
fetched are used. Any extra field values are ignored.0

\subsection{\co{SQL-FETCH-AS-OBJECT}}
TODO

Makes WMOs from selected database records by executing a
SELECT statement.

This action creates instances of a single OBJECT-CLASS only,
even if it is retrieving data from multiple tables (for
example, a join between source tables). The OBJECT-CLASS
matches the (first) table name specified in the FROM clause
of the select expression. SQLFETCH-AS-OBJECT creates one new
object from each database record selected.

The database field names and the attribute names of the
OBJECT-CLASS must match. Any selected fields that do not have
a corresponding attribute are ignored. Any attributes that do
not have a corresponding field are set to their DEFAULT
values (if one was declared) or NIL. Attributes that
correspond to fields whose value is "missing" are also set to
NIL.

You can use the SQL-FETCH-AS-OBJECT action as the value
argument to a BIND action. The variable argument of the BIND
action is bound to a compound value that contains the
INSTANCE-IDs of all the fetched WMOs.



\Format

SQL-FETCH-AS-OBJECT select~expr



*Argument

select-expr

An SQL select expression that restricts the fetch to specific
database records and specifies which database fields are to
be fetched. The database table specified in the select
expression is used as the object class name for the objects
created by the SQL-FETCH-AS-OBJECT operation.



*Return Value

When used as in the second argument to the BIND action, the
SQL-FETCH-AS-OBJECT action returns a compound value that
contains the INSTANCE-IDs of all the objects created.



\Example

In the first example, selected records from table W1 are
fetched and used to create objects. Only records with field
fld1 having a value less than field fld2 are fetched. (This
is a numeric comparison; the last two examples use character
string fields.)



(SQL-FETCH-AS-OBJECT SELECT * FROM W1 WEERE fld1 < fld2 )



Any objects created by this action are instances of
OBJECT-CLASS W1, as specified in the FROM clause. All record
fields are used and mapped into object attributes, as
requested by the use of an asterisk (*) in the select
expression.



(SQL-FETCH-AS-OBJECT SELECT fld1, fld2, fld3 FROM W1 WHERE
fld1 < fld2)



The example above refines the first example by fetching
fields fld1, fld2, and fld3 only. Again, as in the previous
example, only records with field fld1 value less than that of
fld2 are fetched.



(SQL-FETCH-AS-OBJECT SELECT DISTINCT fld1, fld2 FROM W1 WHERE
fld1 < fld2)







This example illustrates the DISTINCT qualifier, which
restricts the new W1 objects to unique combinations of fld1
and fld2 values. Without the DISTINCT qualifier this action
can yield multiple duplicate objects, depending on the
database contents.



(SQL-FETCH-AS-OBJECT SELECT fld1, fld2, DBKEY From W1 WHERE
fld1 < fld2 )



This example fetches the DBKEY for each database record,
along with the fld1 and fld2 values. The OBJECT-CLASS
declaration for W1 in this case must include a DBKEY
attribute, so that the action has a place to put the DBKEY
value.



(SQL-FETCH-AS-OBJECT SELECT W1. *, DBKEY FROM W1 WHERE fld1 <
f1d2)



The action above shows how to select all fields and capture
the DBKEY values. The required syntax is not the SELECT *,
DBKEY that you might expect.



(SQL-FETCH-AS-OBJECT SELECT * FROM W1 WHERE fld1 = 'abc' AND
fld2 = '<var>')



This example uses string field comparisons in the select
expression. Only those records that have fld1 equal to the
string 'ABC' and fld2 equal to the string bound to the
RuleWorks variable <var> are selected and fetched. Note that
RuleWorks automatically converts the symbol 'abc' to the
string 'ABC'.



(bind <x> (SQL-FETCH-AS-OBJECT

SELECT * FROM W1 WHERE fld1 = 'abc' AND fld2 = '<var>'))



This example shows the previous SQL-FETCH-AS-OBJECT action
used as an argument to the BIND action.

\subsection{\co{SQL-INSERT}}
TODO

Stores new records in the specified database table by
executing an INSERT statement. The fields to be set, and
their new values, are provided in the second argument.

This action can be executed only within the context of a READ
WRITE transaction, which you must explicitly start with an
SQL-START action.



\Format

SQL-INSERT table-name SQL-expr



*Arguments

Table-name

Specifies the database table into which the new records are
to be inserted.

SQL-expr

An SQL expression that specifies the target fields and their
values.



\Example

In this example a new record is created in database table
\verb|tbl_l|, with its field fld2 set to 123 and its field fld5 set
to the string 'test'. The SQL expression is enclosed in
vertical bars because it includes parentheses.

\begin{quote}
\begin{verbatim}
(SQL-INSERT tbl_1 | (f1d2, fld5) VALUES (123, 'test') |)
\end{verbatim}
\end{quote}

The next example is similar to the previous one, except that
one of the field names is defined at run-time by the
RuleWorks variable <v2> and the value for field fld5 is given
by the RuleWorks variable <v2>.
\begin{quote}
\begin{verbatim}
(SQL-INSERT tbl_1 |(| <v1> |, fld5) VALUES (456,| '<v2>' |)|
)
\end{verbatim}
\end{quote}

Since fld5 is a character (string) field, the value
substituted for <v2> must be enclosed in single quotes.

Note: that both unquoted and quoted variables must be
preceded and followed by whitespace, as in this example.
Also, parentheses that are passed to SQL must be enclosed in
vertical bars.

\subsection{\co{SQL-INSERT-FROM-OBJECT}}
TODO

Stores the contents of a specified object in a new database
record by executing an INSERT statement. The record is
inserted into the database table that has the same name
object's OBJECT~CLASS. The values of the object's \verb|^$ID| and
\verb|^$INSTANCE-OF| attributes are not written to the database,
even if the database explicitly provides fields with those
names.

This action can be executed only within the context of a READ
WRITE transaction, which you must explicitly start with a
SQL-START action.



\Format

SQL-INSERT-FROM-OBJECT <\verb|^$ID-variable|>

\Argument

\verb|<^$ID-variable>|

A variable bound to the value of the \verb|^$ID| attribute of the
object to be stored.



\Example

In this example the object identified by the <W> object
identifier is inserted into the database, into the table
having the same name as the <W> object's OBJECTCLASS- After
the SQL-INSERT-FROM-OBJECT, you are free to remove the <W>
object or leave it in working memory.



(SQL-INSERT-FROM-OBJECT <W>)

\subsection{\co{SQL-ROLLBACK}}

Undoes any changes to the database made during the current transaction
and completes the transaction. This action executes a \co{ROLLBACK}
statement.

\Format

\co{SQL-ROLLBACK}

\Arguments

None.

\subsection{\co{SQL-START}}
TODO

Executes a SET TRANSACTION statement to start a transaction
with the specified options. These options can include a READ
ONLY versus a READ WRITE transaction, and whether to retain
any locks obtained on records during the course of the
transaction.

You end the transaction started by this action with an
SQL-COMMIT, SQL-DETACH, or SQL-ROLLBACK action.



\Format

SQL-START [txn-options]



*Argument

Txn-options

Optional list of desired SQL transaction options. If this
argument is not provided, a READ ONLY transaction is the
default.



\Example

The first example starts a READ ONLY transaction by default,
because it has no transaction options.



(SQL-START)



The following example shows an update transaction whose
options request that any records accessed during the
transaction have locks retained on them, so that the records
may be updated again (in protected write mode).



(SQL-START |READ WRITE RESERVING W1 FOR PROTECTED WRITE| )



The vertical bars in this example are not required, but they
do make the action more efficient.

\subsection{\co{SQL-UPDATE}}
TODO

Modifies the contents of selected database records, where the
fields to be modified and their new values are specified in
the second argument.

This action can be executed only within the context of a READ
WRITE transaction, which must be explicitly started by an
SQL-START action.



\Format

SQL-UPDATE table-name SET-clause [WHERE-clause]



*Arguments

Table-name

Specifies database table to be modified.

SET-clause

An SQL expression to define which fields are to be updated
within the target table, and the new values for these fields.

WHERE-clause

An optional select expression that specifies which database
records are updated.

If it is omitted, the default action is to update all records
in the specified table.



\Example

The first example sets the numeric fld1 field value in all W1
table records, if any, to zero, and sets the char field fld2
to 'SOME TEXT')



(SQL-UPDATE W1 SET fld1 = 0, fld2 = 'some text' )



The second example modifies any and all records in the W1
table whose previous field a1 value was the old value <val>
(bound in LHS of the rule) and field whose field a2 value was
<va12>. These records have al set to <new-val> (bound on the
RHS of the rule).
\begin{quote}
\begin{verbatim}


(rule sql-update-example

(W1 ^$ID <W1> ^a1{  < 10 <val> } ^a2  <val2>

à

(bind <new-val> (<val> + 10))

(modify <W1> ^a1  <new-val>)

(SQL-UPDATE W1 SET al = <new-val> WHERE al = <val>, a2 =
<val2> ))
\end{verbatim}
\end{quote}

\subsection{\co{SQL-UPDATE-FROM-OBJECT}}
TODO

Uses the attribute values of an object to modify corresponding data
fields in one or more existing database records. The values of the
object's \verb|^$ID| and \verb|^$INSTANCE-OF| attributes are not
written to the database, even if the database explicitly provides
fields with those names.

This action can only be executed within the context of a READ
WRITE transaction, which you must explicitly start with an
SQL~START action.

\Format

SQL-UPDATE-FROM-OBJECT \verb|<$ID-variabl>| [where-clause ]

*Arguments

\verb|<$ID-variable>|

A variable bound to the \verb|^$ID| attribute of the object to be
used. The OBJECT-CLASS name of the associated object specifies the database
table that is modified.

WHERE-clause

Optionally identifies which database records are to be
modified using the object attribute values. If it is omitted,
the default action is to update all records.

\Example

The first example uses the attribute values in the object
whose INSTANCE-ID is bound to <W> to modify database records
whose field fld1 is equal to the value bound to the RuleWorks
variable <var1> and whose character field fld2 is equal to
the value bound to <var2>. This WHERE clause may or may or
not be sufficiently restrictive to make the
SQL-UPDATE-FROM-OBJECT action modify only one database
record.



(SQL-UPDATE-FROM-OBJECT <W> WHERE fld1 = <var1> AND f1d2 =
'<var2>')



The database table containing the record(s) to be modified is
the table with the same name as the OBJECT-CLASS of the
object identified by the \verb|$ID| variable <W1>. Note that the
white space around the quoted variable ('<var2>' in this
example) is required.
\begin{quote}
\begin{verbatim}
(rule sql-update-from-object-example

(W1 ^$ID <W1> ^a1  { < 10 <val> ) ^a2  <val2>)

à

(modify <w1> ^a1  (<val> + 10))

(SQL-UPDATE-FROM-OBJECT <w1> WHERE al = <val> AND a2 = <val2>))
\end{verbatim}
\end{quote}

The above example modifies any and all records in the W1 table whose
previous field al value was the old value \verb|<val>| (bound in LHS
of the rule) and whose field \verb|a2| value was \verb|<val2>|. These
records have field al set to the newly-computed value of the
\verb|^A1| attribute (the object was modified just before the
\co{SQL-UPDATE-OBJECT} action).

\subsection{\co{SUBCOMPOUND}}

Creates a new compound value that is a subrange of an existing
compound value. \co{SUBCOMPOUND} is a stateless function and can be
used on the LHS or RHS.

\Format

\co{SUBCOMPOUND} \it{compound-val} \it{index-1} \it{index-2}

\begin{arguments}
\item[compound-val]

  The compound value from which a subrange is returned. This argument
  can be a bound compound variable or a function that returns a
  compound value.

\item[index-1 index-2]

  The positions of the first and last elements in the subrange,
  respectively. These arguments can be either of the following:
  
  Anything that evaluates to an integer greater than zero.

  The special symbol \verb|$LAST|.

  The \it{index-1} argument must be less than or equal to the
  \it{index-2} argument.

  Note that
  \verb|$LAST| may not be used as part of an expression; it must stand
  alone.
\end{arguments}

\Example

The following rule uses the SUBCOMPOUND function to remove
the first element of a compound value:
\begin{quote}
\begin{verbatim}
(rule pop-stack
    (agenda ^$ID <my-agenda> ^tasks <tasks>)
  -->
    (modify <my-agenda> ^tasks (subcompound <tasks> 2 $last)))
\end{verbatim}
\end{quote}

\subsection{\co{SUBSYMBOL}}

Creates a new symbol value that is a fragment of an existing symbol
value. \co{SUBSYMBOL} is a stateless function and can be used on
either the LHS or RHS.

\Format

\co{SUBSYMBOL} \it{symbol-val} \it{index-1} \it{index-2}

\begin{arguments}
\item[symbol-val]

  The symbol value from which a fragment is returned. This argument
  can be a bound symbol variable or a function that returns a symbol
  value.

\item[index-1 index-2]

  The positions of the first and last characters in the return value,
  respectively. These arguments can be either of the following:

  Anything that evaluates to an integer greater than or equal to one

  The special symbol \verb|$LAST|

  The \it{index-1} argument must be less than or equal to the
  \it{index-2} argument.
\end{arguments}

Note that \verb|$LAST| may not be used as part of an expression; it
must stand alone.

\ReturnValue

A symbol that contains the specified fragment of the input symbol. If
the fragment is specified incorrectly or does not exist, the function
returns the empty symbol value, 11.

\subsection{\co{SYMBOL}}

Converts any value into a symbol. \co{SYMBOL} is a stateless function
and can be used on either the LHS or RHS.

\Format

\co{SYMBOL} \it{value-expr}

\begin{arguments}
\item[value-expr]

  An expression that evaluates to the value to be converted.
\end{arguments}

\ReturnValue

The symbolic atom that corresponds to the specified value. In other
words, the atom of type \co{SYMBOL} whose print form is identical to
the print form of the argument.

The print form of a compound value includes a space between the
elements, but does not include the function name \co{COMPOUND} or its
parentheses. If the compound is too long to fit in a symbol, it is
truncated.

\subsection{\co{SYMBOL-LENGTH}}

Returns the number of characters in a symbol. \co{SYMBOL-LENGTH} is a
stateless function and can be used on either the LHS or RHS.

(See also the \co{LENGTH} function, which returns the number of
elements in a compound value.)

\Format

\co{SYMBOL-LENGTH} \it{symbol-val}

\begin{arguments}
\item[symbol-val]

  The symbolic value to be measured. This argument can be a bound
  symbolic variable or a function that returns a symbolic value.
\end{arguments}

\ReturnValue

An integer that specifies the number of characters in the symbol.

\subsection{\co{TABTO}}

Causes the \co{WRITE} action to start writing output in a specified
column.

\begin{note}
  The \co{TABTO} function is valid only inside the \co{WRITE} action.
\end{note}

\Format

\co{TABTO} \it{column}

\begin{arguments}
\item[column]

  An integer expression that indicates the column in which the
  \co{WRITE} action is to start writing output. If you specify a
  column that is to the left of the last column in which output is
  written, the \co{WRITE} action writes the output on a new line,
  starting at the specified column.
\end{arguments}

\Example

The following \co{WRITE} action displays the headers of three
columns:
\begin{quote}
\begin{verbatim}
(write (crlf) 
    (tabto 10) number
    (tabto 25) amount
    (tabto 40) date)
\end{verbatim}
\end{quote}
     
The output is:
\begin{quote}
\begin{verbatim}
          NUMBER         AMOUNT         DATE
\end{verbatim}
\end{quote}

\subsection{\co{TRACE}}

Displays or changes the run-time system's trace setting, which
controls the amount of information the system displays while executing
a program.

\begin{note}
  The \co{TRACE} action in source code is effective only when the entry
  block that contains it was compiled with the Debug qualifier set to
  \co{YES} or \co{MAYBE}.
\end{note}

\Format

\co{TRACE} [\co{ON} \it{trace-name} \ldots \co{OFF} \co{*}]

\begin{arguments}
\item[trace-name]

  The name of a trace setting, which are shown in the table below. You
  can supply one or more names.

\item[\normalfont\texttt{*}]

  All trace settings shown in the following table.
\end{arguments}

\begin{tabular}{ll}
  \toprule
  Name & Information Displayed \\
  \midrule
  \co{ENTRY-BLOCK} or \co{EB} & Entry blocks being entered or exited \\
  \co{RULE} & Global and local rule firing counts and instantiation
executed \\
  \co{ENTRY-BLOCK} or \co{EB} & Entry blocks being entered or exited \\
  \co{RULE-GROUP} or \co{RG} & Global and local rule firing counts and instantiation executed \\
  \co{WM} & Objects being created, changed, or deleted from working
memory \\
  \co{CS} & Instantiations into and out of the conflict set \\
  \co{PM} & Rules into and out of program memory \\
  \bottomrule
\end{tabular}

\Example

The following command displays the current trace level:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace}
   TRACEs set on:  ENTRY-BLOCK RULE-GROUP RULE WM CS
\end{Verbatim}
\end{quote}

The following commands change and redisplay the trace
setting:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{trace off rg rule}
   TRACEs set on:  ENTRY-BLOCK WM CS
\end{Verbatim}
\end{quote}  

For examples of trace output, see Section~\ref{s:trace}.

\subsection{\co{WBREAK}}

Controls breakpoints on WMOs that match a specified pattern.

When used with no arguments, the command displays a numbered list of
the object patterns that have breakpoints set. When used with the
\co{ON} and \co{OFF} keywords, respectively, \co{WBREAK} sets and
clears breakpoints for object patterns.

Any rule that makes, copies, modifies, specializes, or removes an
object that matches a pattern triggers the breakpoint on that
pattern. When the run-time system encounters a breakpoint on an object
pattern, it completes the current recognize-act cycle and displays
messages in the format below, and invokes the command interpreter:

\begin{quote}
\begin{verbatim}
%RUL-I-WBREAK, WBREAK encountered on class-name #instance-id
%RUL-I-BREAKNOTED, Execution paused by break
\end{verbatim}
\end{quote}

\Format

\co{WBREAK} [\co{ON} \it{object pattern} \co{OFF} \{\it{object-pattern}
\it{number} \co*\}]

\begin{arguments}
\item[\normalfont\co{ON}]

  Sets a new breakpoint on an object pattern.

\item[\normalfont\co{OFF}]

  Clears the existing breakpoint on an object pattern.

\item[object-pattern]

  An expression, similar to a CE, that defines which objects cause a
  break. The object pattern must include the name of an object class
  that is visible to the active entry block, and may include any
  number of attribute-value tests.

  If the class name in the object pattern has inheriting subclasses,
  objects of those subclasses also match the pattern.

\item[number]

  An integer corresponding to an object pattern that currently has a
  breakpoint set. You get a list of integers and their patterns when
  you give the \co{WBREAK} command with no arguments.

\item[\normalfont\co{*}]

  You can use an asterisk (star) with the \co{OFF} keyword to mean
  ``clear all breakpoints on WMOs.''
\end{arguments}

\Example

The following is an example of the \co{WBREAK} command:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wbreak on control-context}
\RWP\cmd{run}
<FAC>-I-WBREAK, WBREAK encountered on ACTIVE-CONTEXT #2
=>WM: #2 [MAKE-CONTEXT-ACTIVE] (ACTIVE-CONTEXT ^NAME TASKS-TO-DO)
<=WM: #1 [ | main | ON-ENTRY] (CONTEXT ^NAME TASKS-TO-DO)
%RUL-I-BREAKNOTED, Execution paused by break
\RWP
\end{Verbatim}
\end{quote}

\subsection{\co{WHILE}\ldots\co{DO}\ldots}

Repeatedly executes one or more RHS actions as long as a relational
expression remains true. In other words, provides a loop in the flow
of control.

\Format

\co{WHILE} \co(\it{rel-expr}\co) \co{DO} \it{RHS-action}

\begin{arguments}
\item[rel-expr]

  A relational expression that determines whether RHS actions are to
  be executed. This argument must evaluate to eithe rtrue or false. It
  may not contain any SQL functionc.

\begin{note}
  RuleWorks does not have Boolean values. Therefore, this argument
  must be a comparison of two expressions. It must not be a single
  value. For example, RuleWorks does not allow
  \verb|(WHILE (TRUE) DO.)|.
\end{note}

\item[RHS-action]

  Any RuleWorks action. You can specify any number of actions.
\end{arguments}

\Clause

\co{DO}

Specifies the actions that are to be executed as long as the
relational expression remains true. This clause is required.

\Example

The example below illustrates a simple relational expression in a
\co{WHILE}:

\begin{quote}
\begin{verbatim}
(while (<sun_shines> = true) do
       (make hay))
\end{verbatim}
\end{quote}
     
\subsection{\co{WM}}

Displays the objects whose \co{INSTANCE-ID}s are specified. The output
includes the following information about each object:

\begin{itemize}
\item Its \co{INSTANCE-ID}.

\item The name of the construct that last modified the object (for
  example, a rule or \co{ON-} clause). If you last modified the object
  at the interpreter prompt, the construct name is the symbol \co{RUL}.

\item Its attributes' names and their values.

\item Scalar attributes whose value is \co{NIL}, and compound attributes
  whose value is \co{(COMPOUND)}, are not displayed unless you have
  declared a \co{DEFAULT} value for the attribute.
\end{itemize}

The system displays this information in the following format:

\verb|#|\it{instance-id} \verb|[|\it{block-name/rule-name}\verb|]| \verb|(|\it{class-name} \it{attribute-1} \it{value-1} \it{attribute-2} \it{value-2} \ldots\verb|)|

\Format

\co{WM} [\it{instance-id}] \ldots

\begin{arguments}
\item[instance-id]

  An \co{INSTANCE-ID} atom that identifies an object that the command
  is to display. You can specify one or more \co{INSTANCE-ID}s.

  The argument is optional. If you do not specify any \co{INSTANCE-ID}s,
  the command displays all the visible WMOs.
\end{arguments}

\Example

The following command displays the objects whose identifiers are
\verb|#3| and \verb|#4|:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wm #3 #4}
\end{Verbatim}
\end{quote}

\subsection{\co{WMHISTORY}}

Displays the history of a specified object, that is, which rules set
the attribute values. You must specify the \co{INSTANCE-ID} of the desired
object; you may also specify a particular attribute.

When the \co{WMHISTORY} command displays an entire object, the
output includes the following information:
\begin{itemize}
\item \co{INSTANCE-ID}
\item Name of the rule that last modified the object
\item Object class name
\item Name of the rule that originally created the object
\item Name and value of each attribute
\item Name of the rule that set the current value of each attribute
\end{itemize}

Scalar attributes whose value is \co{NIL}, and compound attributes whose
value is \co{(COMPOUND)}, are not displayed unless you have declared a
\co{DEFAULT} value for the attribute.

The system displays this information in the following format:

\verb|#|\it{instance-id} \verb|[|\it{rule-name-0}\verb|]| \verb|(|\it{class-name} \verb|[|rule-name\verb|]| \{ \ct\it{attr-1} \it{value-1} \verb|[|\it{rule-name-1}\verb|]|\} \ldots

When the \co{WMHISTORY} command displays a single attribute, the
output includes the following information:

\begin{itemize}
\item \co{INSTANCE-ID}
\item Name of the rule that last modified the object
\item Name and value of the specified attribute
\item Name of the rule that set the current value of the specified
  attribute
\end{itemize}

The system displays this information in the following format:

\verb|#|\it{instance-id} \verb|[|\it{rule-name-0}\verb|]| \ct\it{attribute} \it{value} \verb|[|\it{rule-name-n}\verb|]|

\begin{note}
  By default, \co{WMHISTORY} is disabled. You must turn it on with the
  \co{ENABLE} command before you can use it.
\end{note}

\Format

\co{WMHISTORY} \it{instance-id} [\ct\it{attribute}]

\begin{arguments}
\item[instance-id]

  The \co{INSTANCE-ID} of the object to be displayed.

\item[attribute]

  An attribute that describes a characteristic of the object to be
  displayed. This argument is optional. You can use at most one
  attribute name in a WMHISTORY command.
\end{arguments}

\Example

The following example shows the history of an entire object:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{enable wmhistory}
\RWP\cmd{run}
...
\RWP\cmd{wmh #28}
#28 [CHOOSE-SLOTS:PLACE-NONMEMORY] (BOX
[CONVERT-PACKAGES-TO-PARTS:HOME-KIWI] ^CARD-IN-SLOT (COMPOUND
MEMORY MEMORY KEYBOARD FD-35) [CHOOSE-SLOTS:PLACE-NONMEMORY]
^CARD-IN-SLOT-OBJ-ID (COMPOUND #31 #39 #37 #45)
[CHOOSE-SLOTS:PLACE-NONMEMORY] ^NAME BOX
[EXPAND-PART-SKELETONS:BOX] ^PART-NUMBER KI-9200
[EXPAND-PART-SKELETONS:BOX] ^PRINTNAME Kiwi-9200 CPU Base
Unit [EXPAND-PART-SKELETONS:BOX] ^PRICE 999.95
[EXPAND-PART-SKELETONS:BOX] ^IS-EXPANDED YES
[EXPAND-PART-SKELETONS:BOX])
\end{Verbatim}
\end{quote}

This example shows the history of an attribute:

\begin{quote}
\begin{Verbatim}[commandchars=\\\{\}]
\RWP\cmd{wmh #28 ^card-in-slot}
#28 [CHOOSE-SLOTS:PLACE-NONMEMORY] (BOX
[CONVERT-PACKAGES-TO-PARTS:HOME-KIWI] ^CARD-IN-SLOT (COMPOUND
MEMORY MEMORY KEYBOARD FD-35) [CHOOSE-SLOTS:PLACE-NONMEMORY])
\end{Verbatim}
\end{quote}

\subsection{\co{WRITE}}

Sends output from a program to the terminal or a file. By
default, the \co{WRITE} action sends output to the terminal. To
send output to a file, you can do one of the following:

\begin{itemize}
\item specify the \co{WRITE} action with a file identifier,
\item change the default destination for the \co{WRITE} action, using
  the \co{DEFAULT} action or command.
\end{itemize}

\Format

\co{WRITE} [\it{file-id}] \it{RHS-expression}

\begin{arguments}
\item[file-id]

  The file identifier of the destination file for the \co{WRITE}
  action's output. This argument is optional. If you do not specify
  the Argument or if the name you specify is not associated with an
  open output file, the output is sent to the current default for the
  \co{WRITE} action (set with the \co{DEFAULT} action or command).

\item[RHS-expression]

  A right-hand-side expression that represents the output. The action
  evaluates the expression and sends the output to the terminal or a
  file. Use the following functions to format the output:

\begin{center}
  \begin{tabular}{ll}
    \toprule
    Function & Description \\
    \midrule
    \co{CRLF} & Carriage return/line feed \\
    \co{TABTO} & Tab \\
    \co{RJUST} & Right-justify \\
    \bottomrule
  \end{tabular}
\end{center}

If you do not use these functions, the \co{WRITE} action displays its
output on the current output line with one space between values. For
information about using these functions, see Chapter~\ref{c:actions}.
\end{arguments}

\Example

The following \co{WRITE} action is from the rule
\co{OUTPUT-HARDWARE-OPTIONS:WITH-SLOT}:

\begin{quote}
\begin{verbatim}
(write (crlf) <num> (tabto 12) RuleWorks
       (tabto 50) |in Slot:| <slot-num> (tabto 65) (rjust 10)
       <price>)
\end{verbatim}
\end{quote}

This action produces the following output:

\begin{quote}
\begin{verbatim}
FD-35 3.5" Floppy Disk Drive in Slot: 4 99.95
KB-9200 108-Key Keyboard with Mouse Port in Slot: 3 99.95
MS-9200 Kiwi-9200 Memory card in Slot: 2 129.95
MS-9200 Kiwi-9200 Memory card in Slot: 1 129.95
\end{verbatim}
\end{quote}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rwug"
%%% End:
